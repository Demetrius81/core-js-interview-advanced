# CoreJS Interview #2

## Кратко и тезисно темы интервью для самопроверки и повторения ранее изученного материала

### Темы по JavaScript:

#### **Модули в JavaScript**

- [Назначение и концепция шаблона Module.](#1-назначение-и-концепция-шаблона-module)
- [Типы модулей (AMD, ES6, CommonJS, UMD).](#2-типы-модулей-amd-es6-commonjs-umd)
- [Синтаксис и общие функции (export default, named exports, exports as).](#3-синтаксис-и-общие-функции-export-default-named-exports-exports-as)
- [Динамический импорт.](#4-динамический-импорт)

#### **Функциональные шаблоны**

- [Колбэки и IIFE.](#5-колбэки-и-iife)
- [Ограничения колбэков (например, callback hell).](#6-ограничения-колбэков-например-callback-hell)
- [Каррирование функций и частичные функции.](#7-каррирование-функций-и-частичные-функции)

#### **Объектно-ориентированное программирование (ООП)**

- [Функциональность ключевого слова `new`.](#8-функциональность-ключевого-слова-new)
- [Функции-конструкторы и их свойства.](#9-функции-конструкторы-и-их-свойства)
- [Публичные, частные и статические члены в ООП.](#10-публичные-частные-и-статические-члены-в-ооп)

#### **Классы ECMAScript**

- [Объявление класса и синтаксис.](#11-объявление-класса-и-синтаксис)
- [Различия между объявлениями классов и функциями-конструкторами.](#12-различия-между-объявлениями-классов-и-функциями-конструкторами)
- [Использование `super()`.](#13-использование-super)

#### **Прототипическое наследование**

- [Свойства, такие как `__proto__` и `prototype`.](#14-свойства-такие-как-__proto__-и-prototype)
- [Использование [Object.create] для явного определения прототипов.](#15-использование-objectcreate-для-явного-определения-прототипов)

#### **Расширенные типы данных и выражения ECMAScript**

- [`Set/Map` и `WeakSet/WeakMap`.](#16-setmap-и-weaksetweakmap)

#### **Ошибки JavaScript**

- [Методы обработки ошибок, включая `try..catch`.](#17-методы-обработки-ошибок-включая-trycatch)
- [Понимание и реализация пользовательских ошибок.](#18-понимание-и-реализация-пользовательских-ошибок)

#### **ECMAScript Расширенный**

- [Promises, async/await и Event loop.](#19-promises-asyncawait-и-event-loop)
- [Основы сбора мусора.](#20-основы-сбора-мусора)

### JavaScript в браузере:

#### **Глобальный объект window**

- [Понимание location браузера и history API.](#21-понимание-location-браузера-и-history-api)
- [Анализ user-agent и определение платформы/браузера (объект navigator).](#22-анализ-user-agent-и-определение-платформыбраузера-объект-navigator)

#### **Жизненный цикл страницы**

- [Parsing, reflow, repaint и критический путь рендеринга.](#23-parsing-reflow-repaint-и-критический-путь-рендеринга)

#### **Сетевые запросы**

- [Использование «Fetch» ​​и понимание «XMLHTTPRequest».](#24-использование-fetch-и-понимание-xmlhttprequest)

#### **Таймеры**

- [Различия между setTimeout и requestAnimationFrame.](#25-различия-между-settimeout-и-requestanimationframe)

### TypeScript:

* Написание эффективного TypeScript с использованием базовых типов, перечислений, интерфейсов и дженериков:
  - [основные типы](#26-основные-типы)
  - [перечисления](#27-перечисления)
  - [тип/интерфейс, различия между ними](#28-типинтерфейс-различия-между-ними)
  - [использование интерфейсов с необязательными свойствами, свойствами только для чтения и т. д.](#29-использование-интерфейсов-с-необязательными-свойствами-свойствами-только-для-чтения-и-т-д)
  - [типы функций](#30-типы-функций)
  - [utility types `(необязательно)`](#31-utility-types-необязательно)
  - [type guards `(необязательно)`](#32-type-guards-необязательно)
  - [создание пользовательских типов](#33-создание-пользовательских-типов)
  - [дженерики `(концепция)`](#34-дженерики-концепция)
* [Понимание системы модулей в ES6 и TypeScript.](#35-понимание-системы-модулей-в-es6-и-typescript)

### Паттерны проектирования:

- [Знакомство с паттернами порождающие, структурные и поведенческие.](#36-знакомство-с-паттернами-порождающие-структурные-и-поведенческие)
- [Принципы SOLID и паттерны проектирования в контексте проекта.](#37-принципы-solid-и-паттерны-проектирования-в-контексте-проекта)

### Методологии разработки программного обеспечения:

- [Методологии Agile, Scrum, Kanban и Waterfall.](#38-методологии-agile-scrum-kanban-и-waterfall)
- [Методы оценки проекта.](#39-методы-оценки-проекта)

### Тестирование:

- [Понимание различных типов тестирования (Integration, E2E, Performance).](#40-понимание-различных-типов-тестирования-integration-e2e-performance)
- [Пирамида тестирования.](#41-пирамида-тестирования)
- [Разработка через тестирование (TDD) и разработка через поведение (BDD).](#42-разработка-через-тестирование-tdd-и-разработка-через-поведение-bdd)

### Протоколы веб-коммуникаций:

- [Различия между HTTP и HTTPS.](#43-различия-между-http-и-https)
- [Понимание методов HTTP, заголовков, ответов и кодов состояния.](#44-понимание-методов-http-заголовков-ответов-и-кодов-состояния)
- [Концепции RESTful API.](#45-концепции-restful-api)

### Общие знания в области веб-безопасности:

- [Базовые концепции безопасности, включая CORS, XSS и OWASP Top 10.](#46-базовые-концепции-безопасности-включая-cors-xss-и-owasp-top-10)
- [Механизмы аутентификации (JWT, OAuth).](#47-механизмы-аутентификации-jwt-oauth)

---

## 1. Назначение и концепция шаблона Module.

«Модуль» — это популярная реализация паттерна, инкапсулирующего приватную информацию, состояние и структуру, используя замыкания. Это позволяет оборачивать публичные и приватные методы и переменные в модули, и предотвращать их попадание в глобальный контекст, где они могут конфликтовать с интерфейсами других разработчиков. Паттерн «модуль» возвращает только публичную часть API, оставляя всё остальное доступным только внутри замыканий.

Это хорошее решение для того, чтобы скрыть внутреннюю логику от посторонних глаз и производить всю тяжелую работу исключительно через интерфейс, который вы определите для использования в других частях вашего приложения. Этот паттерн очень похож на немедленно-вызываемые функции (IIFE), за тем исключением, что модуль вместо функции, возвращает объект.

 - [https://largescalejs.ru/module-pattern/](https://largescalejs.ru/module-pattern/)
 - [https://medium.com/nuances-of-programming/изучаем-шаблоны-проектирования-в-javascript](https://medium.com/nuances-of-programming/%D0%B8%D0%B7%D1%83%D1%87%D0%B0%D0%B5%D0%BC-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-99ad7bc861c8)
 - [https://webdevblog.ru/shablon-modul-v-javascript/](https://webdevblog.ru/shablon-modul-v-javascript/)

## 2. Типы модулей (AMD, ES6, CommonJS, UMD).

Модуль — это переиспользуемая часть кода, содержащая в себе детали реализации и предоставляющая открытое API, что позволяет легко загрузить её и использовать в другом коде.

Вот несколько наиболее известных и широко используемых:

 - асинхронное определение модуля (Asynchronous Module Definition или AMD);
 - CommonJS;
 - универсальное определение модуля (Universal Module Definition или UMD);
 - System.register;
 - формат модуля ES6.

#### Асинхронное определение модуля (AMD)

Формат AMD используется в браузерах и применяет для определения модулей функцию define:

```javascript
//Вызов функции define с массивом зависимостей и фабричной функцией
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Определение модуля с помощью возвращаемого значения
    return function () {};
});
```

#### Формат CommonJS

Формат CommonJS применяется в Node.js и использует для определения зависимостей и модулей require и module.exports:

```javascript
var dep1 = require('./dep1');  
var dep2 = require('./dep2');

module.exports = function(){  
 // ...
}
```

#### Универсальное определение модуля (UMD)

Формат UMD может быть использован как в браузере, так и в Node.js.

```javascript
(function (root, factory) {
 if (typeof define === 'function' && define.amd) {
   // AMD. Подключение анонимного модуля
     define(['b'], factory);
 } else if (typeof module === 'object' && module.exports) {
   // Node. Не работает с CommonJS напрямую, 
   // только CommonJS-образными средами, которые поддерживают      

   // module.exports, как Node.
   module.exports = factory(require('b'));
 } else {
   // Глобальные переменные браузера (root это window)
   root.returnExports = factory(root.b);
 }
}(this, function (b) {
 //как-нибудь использовать b.

 // Просто возвращаем значение для определения модуля.
 // Этот пример возвращает объект, но модуль 
 // может вернуть и функцию как экспортируемое значение.
 return {};
}));
```

#### System.registerА

Формат System.register был разработан для поддержки синтаксиса модулей ES6 в ES5:

```javascript
import { p as q } from './dep';

var s = 'local';

export function func() {  
 return q;
}

export class C {  
}
```

#### Формат модулей ES6

В ES6 JavaScript уже поддерживает нативный формат модулей.
Он использует токен export для экспорта публичного API модуля:

```javascript
// lib.js

// Экспорт функции
export function sayHello(){  
 console.log('Hello');
}

// Не экспоруемая функция
function somePrivateFunction(){  
 // ...
}
```

 - [https://tproger.ru/translations/js-modules-formats-loaders-builders](https://tproger.ru/translations/js-modules-formats-loaders-builders)
 - [https://learn.javascript.ru/modules-intro](https://learn.javascript.ru/modules-intro)
 - [https://habr.com/ru/articles/501198/](https://habr.com/ru/articles/501198/)

## 3. Синтаксис и общие функции (export default, named exports, exports as).

Модуль – это просто файл. Один скрипт – это один модуль.
Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:

 - export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
 - import позволяет импортировать функциональность из других модулей.

Модули не работают локально. Только через HTTP(s).
Если вы попытаетесь открыть веб-страницу локально, через протокол file://, вы обнаружите, что директивы import/export не работают. Для тестирования модулей используйте локальный веб-сервер, например, static-server или используйте возможности «живого сервера» вашего редактора, например, расширение Live Server для VS Code.

#### Основные возможности модулей:

 - Всегда «use strict»
В модулях всегда используется режим use strict. Например, присваивание к необъявленной переменной вызовет ошибку.
 - Своя область видимости переменных
Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
 - Код в модуле выполняется только один раз при импорте
Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
 - import.meta
Объект import.meta содержит информацию о текущем модуле. Содержимое зависит от окружения. В браузере он содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML.
 - В модуле «this» не определён
В модуле на верхнем уровне this не определён (undefined).
 - Модули являются отложенными (deferred)
Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer. Это верно и для внешних и встроенных скриптов-модулей.
 - Атрибут async работает во встроенных скриптах
Для не-модульных скриптов атрибут async работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ. Для модулей атрибут async работает на любых скриптах.
 - Внешние скрипты
Внешние скрипты с атрибутом type="module" имеют два отличия:
   * Внешние скрипты с одинаковым атрибутом src запускаются только один раз:
   * Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена.Это обеспечивает лучшую безопасность по умолчанию.
 - Не допускаются «голые» модули
В браузере import должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» (bare). Они не разрешены в import. Другие окружения, например Node.js, допускают использование «голых» модулей, без путей, так как в них есть свои правила, как работать с такими модулями и где их искать.
 - Совместимость, «nomodule»
Старые браузеры не понимают атрибут type="module". Скрипты с неизвестным атрибутом type просто игнорируются. Мы можем сделать для них «резервный» скрипт при помощи атрибута nomodule.

#### Синтаксис export:

Перед объявлением класса/функции/…:
`export [default] class/function/variable ...`
Отдельный экспорт:
`export {x [as y], ...}.`
Реэкспорт:
`export {x [as y], ...} from "module"`
`export * from "module"` (не реэкспортирует `export default`).
`export {default [as y]} from "module"` (реэкспортирует только `export default`).

#### Синтаксис import:

Именованные экспорты из модуля:
`import {x [as y], ...} from "module"`
Импорт по умолчанию:
`import x from "module"`
`import {default as x} from "module"`
Всё сразу:
`import * as obj from "module"`
Только подключить модуль (его код запустится), но не присваивать его переменной:
`import "module"`
Мы можем поставить import/export в начало или в конец скрипта, это не имеет значения.
То есть, технически, такая запись вполне корректна:

```javascript
sayHi();

// ...

import {sayHi} from './say.js'; // импорт в конце файла
```

На практике импорты, чаще всего, располагаются в начале файла. Но это только для большего удобства.

 - [https://learn.javascript.ru/modules-intro](https://learn.javascript.ru/modules-intro)
 - [https://learn.javascript.ru/import-export](https://learn.javascript.ru/import-export)
 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export)
 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)

## 4. Динамический импорт.

Выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.
Использовать его мы можем динамически в любом месте кода, например, так:

```javascript
let modulePath = prompt("Какой модуль загружать?");

import(modulePath)
  .then(obj => `<объект модуля>`)
  .catch(err => `<ошибка загрузки, например если нет такого модуля>`)
```

Или если внутри асинхронной функции, то можно `let module = await import(modulePath)`.

Например, если у нас есть такой модуль say.js:

```javascript
// say.js
export function hi() {
  alert(`Привет`);
}

export function bye() {
  alert(`Пока`);
}
```

Динамический импорт работает в обычных скриптах, он не требует указания `script type="module"`.
Хотя `import()` и выглядит похоже на вызов функции, на самом деле это специальный синтаксис, так же, как, например, `super()`.
Так что мы не можем скопировать import в другую переменную или вызвать при помощи .call/apply. Это не функция.

 - [https://learn.javascript.ru/modules-dynamic-imports](https://learn.javascript.ru/modules-dynamic-imports)
 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)

## 5. Колбэки и IIFE.

#### Колбэк-функция

Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.
Вот краткий пример:

```javascript
function greeting(name) {
  alert("Hello " + name);
}

function processUserInput(callback) {
  var name = prompt("Please enter your name.");
  callback(name);
}

processUserInput(greeting);
```

Выше приведён пример синхронного колбэка, поскольку функция processUserInput выполняется синхронно.
Колбэки часто используются для продолжения выполнения кода после завершения асинхронной операции - они называются асинхронными колбэками.

#### IIFE

IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.

```javascript
(function () {
    statements
})();
```

Это тип выражений, также известный как Self-Executing Anonymous Function, который состоит из двух основных частей. 
 - Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки (). Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.
 - Вторая часть создаёт мгновенно выполняющееся функциональное выражение () , благодаря которому JavaScript-движок выполняет функцию напрямую.

Функция становится мгновенно выполняющимся функциональным выражением. Переменные внутри функции не могут быть использованы за пределами её области видимости.

```javascript
(function () {
    var aName = "Barry";
})();
// Variable name is not accessible from the outside scope
aName // throws "Uncaught ReferenceError: aName is not defined"
```

Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.

```javascript
var result = (function () {
    var name = "Barry";
    return name;
})();
// Immediately creates the output:
result; // "Barry"
```

 - [https://developer.mozilla.org/ru/docs/Glossary/Callback_function](https://developer.mozilla.org/ru/docs/Glossary/Callback_function)
 - [https://developer.mozilla.org/ru/docs/Glossary/IIFE](https://developer.mozilla.org/ru/docs/Glossary/IIFE)
 - [https://learn.javascript.ru/callbacks](https://learn.javascript.ru/callbacks)

## 6. Ограничения колбэков (например, callback hell).

#### Что такое «ад обратных вызовов»?

Асинхронный JavaScript или JavaScript, в котором используются обратные вызовы — это то, в чём трудно интуитивно разобраться. В основном код заканчивается вот так:

```javascript
fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err);
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename);
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err);
        } else {
          console.log(filename + ' : ' + values);
          var aspect = (values.width / values.height);
          widths.forEach(function (width, widthIndex) {
            var height = Math.round(width / aspect);
            console.log('resizing ' + filename + 'to ' + height + 'x' + height);
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function (err) {
              if (err) {
                console.log('Error writing file: ' + err);
              }
            });
          }.bind(this));
        }
      });
    });
  }
});
```

Видите форму пирамиды и все эти `})` в конце? Фу! Это ласково называют адом обратных вызовов (callback hell).

#### Как выбраться из ада обратных вызовов?

1. Избегайте большой вложенности функций. Дайте им имена и разместите их на верхнем уровне программы.
2. Используйте поднятие функций чтобы переместить объявление функций в нижнюю часть страницы.
3. Обрабатывайте каждую ошибку в каждом обратном вызове. Для этого подойдёт линтер standard.
4. Создавайте переиспользуемые функции и помещайте их в модули, чтобы сократить время для понимания вашего кода. Разделяйте код на маленькие кусочки — это поможет обрабатывать ошибки, писать тесты, заставит вас создавать стабильный, задокументированный публичный API и облегчит его рефакторинг.

 - [http://callbackhell.ru/](http://callbackhell.ru/)
 - [https://habr.com/ru/articles/319094/](https://habr.com/ru/articles/319094/)

## 7. Каррирование функций и частичные функции.

#### Каррирование

Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
Каррирование не вызывает функцию. Оно просто трансформирует её.

Давайте сначала посмотрим на пример, чтобы лучше понять, о чём речь, а потом на практическое применение каррирования.

Создадим вспомогательную функцию curry(f), которая выполняет каррирование функции f с двумя аргументами. Другими словами, curry(f) для функции f(a, b) трансформирует её в f(a)(b).

```javascript
function curry(f) { // curry(f) выполняет каррирование
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// использование
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
```

Как вы видите, реализация довольна проста: это две обёртки.
Результат curry(func) – обёртка function(a).
Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.

#### Каррирование? Зачем?

Чтобы понять пользу от каррирования, нам определённо нужен пример из реальной жизни.

Например, у нас есть функция логирования log(date, importance, message), которая форматирует и выводит информацию. В реальных проектах у таких функций есть много полезных возможностей, например, посылать логи по сети, здесь для простоты используем alert:

```javascript
function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}
```

А теперь давайте применим к ней каррирование!

```javascript
log = _.curry(log);
```

После этого log продолжает работать нормально:

```javascript
log(new Date(), "DEBUG", "some debug"); // log(a, b, c)
```

…Но также работает вариант с каррированием:

```javascript
log(new Date())("DEBUG")("some debug"); // log(a)(b)(c)
```

Давайте сделаем удобную функцию для логов с текущим временем:

```javascript
// logNow будет частичным применением функции log с фиксированным первым аргументом
let logNow = log(new Date());

// используем её
logNow("INFO", "message"); // [HH:mm] INFO message
```

Теперь logNow – это log с фиксированным первым аргументом, иначе говоря, «частично применённая» или «частичная» функция.
Мы можем пойти дальше и сделать удобную функцию для именно отладочных логов с текущим временем:

```javascript
let debugNow = logNow("DEBUG");

debugNow("message"); // [HH:mm] DEBUG message
```

Итак:
1. Мы ничего не потеряли после каррирования: log всё так же можно вызывать нормально.
2. Мы можем легко создавать частично применённые функции, как сделали для логов с текущим временем.

Для каррирования необходима функция с фиксированным количеством аргументов.
Функцию, которая использует остаточные параметры, типа f(...args), так каррировать не получится.

 - [https://learn.javascript.ru/currying-partials](https://learn.javascript.ru/currying-partials)
 - [https://habr.com/ru/companies/ruvds/articles/427295/](https://habr.com/ru/companies/ruvds/articles/427295/)
 - [https://habr.com/ru/articles/143465/](https://habr.com/ru/articles/143465/) примеры на c#.

## 8. Функциональность ключевого слова `new`.

Ключевое слово `new` в JavaScript используется для создания экземпляра объекта, который содержит функцию конструктора. При вызове функции-конструктора с оператором new выполняются следующие действия:

1. Создается новый пустой объект;
2. Внутреннее свойство prototype нового объекта (__proto__) становится таким же, как и у конструирующей функции;
3. Переменная this указывает на вновь созданный объект. Свойство, объявленное с ключевым словом this, привязано к новому объекту;
4. Созданный объект возвращается, когда функция-конструктор возвращает не примитивное значение (т.е. объект JavaScript). Если функция-конструктор возвращает примитивное значение, оно будет проигнорировано. Если в конце функции ничего не возвращается, то функция возвращает this.

Синтаксис:

```javascript
new СonstructorFunction(arguments)
```

Параметры:

 - `ConstructorFunction`: класс или функция, определяющая тип экземпляра объекта.
 - `Arguments`: список значений, с которыми будет вызываться конструктор.

Рассмотрим пример:

```javascript
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
```

Когда функция вызывается как new User(...), происходит следующее:

 - Создаётся новый пустой объект, и он присваивается this.
 - Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
 - Возвращается значение this.

Другими словами, new User(...) делает что-то вроде:

```javascript
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
```

- [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new)
- [https://learn.javascript.ru/constructor-new](https://learn.javascript.ru/constructor-new)

## 9. Функции-конструкторы и их свойства.

Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна выполняться только с помощью оператора "new".

#### Проверка на вызов в режиме конструктора: new.target

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
В случае обычного вызова функции new.target будет undefined. Если же она была вызвана при помощи new, new.target будет равен самой функции.

```javascript
function User() {
  alert(new.target);
}

// без "new":
User(); // undefined

// с "new":
new User(); // function User { ... }
```

Это можно использовать внутри функции, чтобы узнать, была ли она вызвана при помощи `new`, «в режиме конструктора», или без него, «в обычном режиме».
Также мы можем сделать, чтобы вызовы с new и без него делали одно и то же:

```javascript
function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }

  this.name = name;
}

let john = User("John"); // переадресовывает вызов на new User
alert(john.name); // John
```

Такой подход иногда используется в библиотеках, чтобы сделать синтаксис более гибким. Чтобы люди могли вызывать функцию с new и без него, и она все ещё могла работать.

#### Возврат значения из конструктора, return

Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.
Но если return всё же есть, то применяется простое правило:

 - При вызове return с объектом, вместо this вернётся объект.
 - При вызове return с примитивным значением, оно проигнорируется.

#### Пропуск скобок

Мы можем не ставить круглые скобки после new:

```javascript
let user = new User; // <-- без скобок
// то же, что и
let user = new User();
```

Пропуск скобок считается плохой практикой, но такой синтаксис разрешён спецификацией.

#### Создание методов в конструкторе

Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.

Конечно, мы можем добавить к this не только свойства, но и методы.
Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:

```javascript
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

- [https://learn.javascript.ru/constructor-new](https://learn.javascript.ru/constructor-new)
- [https://metanit.com/web/javascript/4.5.php](https://metanit.com/web/javascript/4.5.php)
- [https://habr.com/ru/articles/151070/](https://habr.com/ru/articles/151070/)

## 10. Публичные, частные и статические члены в ООП.

#### Внутренний и внешний интерфейсы

В объектно-ориентированном программировании свойства и методы разделены на 2 группы:

 - Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
 - Внешний интерфейс – методы и свойства, доступные снаружи класса.

В JavaScript есть два типа полей (свойств и методов) объекта:

 - Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
 - Приватные: доступны только внутри класса. Они для внутреннего интерфейса.

Во многих других языках также существуют «защищённые» поля, доступные только внутри класса или для дочерних классов (то есть, как приватные, но разрешён доступ для наследующих классов) и также полезны для внутреннего интерфейса. В некотором смысле они более распространены, чем приватные, потому что мы обычно хотим, чтобы наследующие классы получали доступ к внутренним полям.

Защищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют.

Защищённые свойства обычно начинаются с префикса _.

Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.

Приватные свойства и методы должны начинаться с #. 

Они доступны только внутри класса.
На уровне языка # является специальным символом, который означает, что поле приватное. Мы не можем получить к нему доступ извне или из наследуемых классов.
Приватные поля не конфликтуют с публичными.

#### Статические свойства и методы

Мы также можем присвоить метод самому классу. Такие методы называются статическими.
В объявление класса они добавляются с помощью ключевого слова static, например:

```javascript
class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // true
```

Это фактически то же самое, что присвоить метод напрямую как свойство функции:

```javascript
class User { }

User.staticMethod = function() {
  alert(this === User);
};
```

Значением this при вызове User.staticMethod() является сам конструктор класса User (правило «объект до точки»).

#### Статические свойства

Статические свойства также возможны, они выглядят как свойства класса, но с static в начале:

```javascript
class Article {
  static publisher = "Илья Кантор";
}

alert( Article.publisher ); // Илья Кантор
```

Это то же самое, что и прямое присваивание Article:

```javascript
Article.publisher = "Илья Кантор";
```

Статические свойства и методы наследуются.

 - [https://learn.javascript.ru/private-protected-properties-methods](https://learn.javascript.ru/private-protected-properties-methods)
 - [https://learn.javascript.ru/static-properties-methods](https://learn.javascript.ru/static-properties-methods)

## 11. Объявление класса и синтаксис.

Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный способ создания объектов и организации наследования.

Синтаксис «class»
Базовый синтаксис выглядит так:

```javascript
class MyClass {
  // методы класса
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```

Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.
При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.

На самом деле классы — это "специальные функции", поэтому точно также, как вы определяете функции (function expressions и function declarations), вы можете определять и классы с помощью: class declarations и class expressions.

**Первый способ определения класса** — class declaration (объявление класса). Для этого необходимо воспользоваться ключевым словом class и указать имя класса (в примере — «Rectangle»).

```javascript
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

**Второй способ определения класса** — class expression (выражение класса). Можно создавать именованные и безымянные выражения. В первом случае имя выражения класса находится в локальной области видимости класса и может быть получено через свойства самого класса, а не его экземпляра.

```javascript
// безымянный
var Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// отобразится: "Rectangle"

// именованный
var Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// отобразится: "Rectangle2"
```

Ключевое слово extends используется в объявлениях классов и выражениях классов для создания класса, дочернего относительно другого класса.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} издаёт звук.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // вызывает конструктор super класса и передаёт параметр name
  }

  speak() {
    console.log(`${this.name} лает.`);
  }
}

let d = new Dog("Митци");
d.speak(); // Митци лает
```

Если в подклассе присутствует конструктор, он должен сначала вызвать super, прежде чем использовать this.

 - [https://learn.javascript.ru/class](https://learn.javascript.ru/class)
 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)
 - [https://habr.com/ru/articles/518386/](https://habr.com/ru/articles/518386/)

## 12. Различия между объявлениями классов и функциями-конструкторами.

Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление функции совершает подъём (hoisted), в то время как объявление класса — нет. Поэтому вначале необходимо объявить ваш класс и только затем работать с ним.

 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

## 13. Использование `super()`.

Ключевое слово super используется для вызова функций, принадлежащих родителю объекта.

В конструкторе ключевое слово super() используется как функция, вызывающая родительский конструктор. Её необходимо вызвать до первого обращения к ключевому слову this в теле конструктора. Ключевое слово super также может быть использовано для вызова функций родительского объекта.

Вы не можете использовать оператор delete и super.prop или super[expr] для удаления свойств родительского класса, он выдаст: ReferenceError.

При определении незаписываемых свойств с помощью, например, Object.defineProperty, super не может перезаписать значение свойства.

 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/super](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/super)
 - [https://learn.javascript.ru/class-inheritance](https://learn.javascript.ru/class-inheritance)

## 14. Свойства, такие как `__proto__` и `prototype`.

#### Свойство `__proto__`

Абсолютно любой объект в JavaScript имеет свойство `__proto__`. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю.
При обращении к любому свойству объекта, оно в первую очередь ищется в самом объекте:

```javascript
var obj = {ownProperty: 1};

console.log(obj.ownProperty);// 1
```

Но если его там нет, поиск происходит в свойстве `__proto__`:

```javascript
obj.__proto__ = {propertyOfProto: 2};
console.log(obj.propertyOfProto);// 2
```

Если его нет и там, оно ищется дальше по цепочке:

```javascript
obj.__proto__.__proto__ = {propertyOfProtosProto: 3};
console.log(obj.propertyOfProtosProto);// 3
```

Эта цепочка называется цепочкой прототипов (prototype chain).

`__proto__` любого значения (кроме null и undefined) ссылается на prototype соответствующего ему типу данных:

```javascript
(0).__proto__ === Number.prototype &&
false.__proto__ === Boolean.prototype &&
"string".__proto__ === String.prototype &&
(new Date).__proto__ === Date.prototype &&
(function(){}/* new Function */).__proto__ === Function.prototype
```

Все типы данных наследуются от Object, это означает что к примеру:

```javascript
Number.prototype.__proto__ === Object.prototype
```

И наконец, завершение цепочки:

```javascript
Object.prototype.__proto__ === null
```

#### Свойство prototype

А чем же тогда является свойство prototype? Это обычное свойство, ничем не отличающиеся от любых других свойств. За исключением двух особенностей:

1. Функции в JavaScript имеют свойство prototype. Оно по умолчанию является объектом с единственным свойством constructor, которое ссылается на саму функцию.
2. Свойство prototype используется при создании новых объектов оператором new.

#### Оператор new

Этот оператор делает следущее:

1. Создает пустой объект:
var instance = {};

2. Устанавливает `__proto__` этому объекту ссылкой на prototype функции-конструктора:
instance.`__proto__` = FnClass.prototype;

3. Применяет функцию-конструктор к нашему новосозданному объекту:
constructorReturns = FnClass.apply(instance, arguments);
(т.е. исполняет функцию FnClass, передавая ей instance в качестве this и аргументы в виде массива arguments)

4. Возвращает экземпляр функции-класса, но если FnClass нам вернул обьект, тогда его:
return constructorReturns instanceof Object ? constructorReturns : instance;

 - [https://learn.javascript.ru/prototype](https://learn.javascript.ru/prototype)
 - [https://habr.com/ru/companies/otus/articles/685528/](https://habr.com/ru/companies/otus/articles/685528/)
 - [https://habr.com/ru/articles/140810/](https://habr.com/ru/articles/140810/)

## 15. Использование [Object.create] для явного определения прототипов.

`Object.create(proto[, descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
У Object.create есть необязательный второй аргумент: дескрипторы свойств.
Дескриптор свойства — это запись с некоторыми из следующих атрибутов:

 - `value` - Значение, ассоциированное со свойством (только в дескрипторе данных).
 - `writable` - Значение true, если значение, ассоциированное со свойством, может быть изменено, иначе false (только в дескрипторе данных).
 - `get` - Функция, возвращающая значение свойства, либо undefined, если такая функция отсутствует (только в дескрипторе доступа).
 - `set` - Функция, изменяющая значение свойства, либо undefined, если такая функция отсутствует (только в дескрипторе доступа).
 - `configurable` - Значение true, если тип дескриптора этого свойства может быть изменён и если свойство может быть удалено из содержащего его объекта, иначе false.
 - `enumerable` - Значение true, если это свойство доступно при перечислении свойств содержащего его объекта, иначе false.

  - [https://learn.javascript.ru/prototype-methods](https://learn.javascript.ru/prototype-methods)
  - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  - [https://habr.com/ru/articles/518360/](https://habr.com/ru/articles/518360/)

## 16. `Set/Map` и `WeakSet/WeakMap`.

#### Map

Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Методы и свойства:

 - `new Map()` – создаёт коллекцию.
 - `map.set(key, value)` – записывает по ключу key значение value.
 - `map.get(key)` – возвращает значение по ключу или undefined, если ключ key отсутствует.
 - `map.has(key)` – возвращает true, если ключ key присутствует в коллекции, иначе false.
 - `map.delete(key)` – удаляет элемент (пару «ключ/значение») по ключу key.
 - `map.clear()` – очищает коллекцию от всех элементов.
 - `map.size` – возвращает текущее количество элементов.

**Перебор Map**

Для перебора коллекции Map есть 3 метода:

 - `map.keys()` – возвращает итерируемый объект по ключам,
 - `map.values()` – возвращает итерируемый объект по значениям,
 - `map.entries()` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

#### Set

Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

 - `new Set(iterable)` – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
 - `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
 - `set.delete(value)` – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
 - `set.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.
 - `set.clear()` – удаляет все имеющиеся значения.
 - `set.size` – возвращает количество элементов в множестве.
Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

**Перебор объекта Set**

Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach.

Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

Set имеет те же встроенные методы, что и Map:

 - `set.values()` – возвращает перебираемый объект для значений,
 - `set.keys()` – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
 - `set.entries()` – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

#### WeakMap и WeakSet

WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map.

То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти.

Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект.

Таким образом, WeakMap избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект.

У WeakMap есть ряд ограничений:

 - Только объекты в качестве ключей.
 - Нет свойства size.
 - Нельзя перебрать элементы итератором или forEach.
 - Нет метода clear().

Иными словами, WeakMap работает только на запись (set, delete) и чтение (get, has) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое WeakMap, нет соответствующих методов.
Это связано с тем, что содержимое WeakMap может быть модифицировано сборщиком мусора в любой момент, независимо от программиста.

То же самое относится и к WeakSet: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.
Эти ограничения могут показаться неудобными, но, по сути, они не мешают WeakMap/WeakSet выполнять свою основную задачу – быть «вторичным» хранилищем данных для объектов, актуальный список которых (и сами они) хранится в каком-то другом месте.

 - [https://learn.javascript.ru/map-set](https://learn.javascript.ru/map-set)
 - [https://learn.javascript.ru/weakmap-weakset](https://learn.javascript.ru/weakmap-weakset)


## 17. Методы обработки ошибок, включая `try..catch`.

Синтаксис «try…catch».

Конструкция try..catch состоит из двух основных блоков: try, и затем catch:

```javascript
try {

  // код...

} catch (err) {

  // обработка ошибки

}
```

Работает она так:

Сначала выполняется код внутри блока try {...}.

Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.

Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

Таким образом, при ошибке в блоке try {…} скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch.

try..catch работает синхронно.
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает.

Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch.

Для всех встроенных ошибок этот объект имеет два основных свойства:

 - `name` - Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
 - `message` - Текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:

 - `stack` - Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.

Если нам не нужны детали ошибки, в catch можно её пропустить.

Конструкция try..catch может содержать ещё одну секцию: finally.

Если секция есть, то она выполняется в любом случае:

 - после try, если не было ошибок,
 - после catch, если ошибки были.

Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

 - [https://learn.javascript.ru/try-catch](https://learn.javascript.ru/try-catch)
 - [https://learn.javascript.ru/exception](https://learn.javascript.ru/exception)

## 18. Понимание и реализация пользовательских ошибок.

Когда что-то разрабатываем, то нам часто необходимы собственные классы ошибок для разных вещей, которые могут пойти не так в наших задачах. Для ошибок при работе с сетью может понадобиться HttpError, для операций с базой данных DbError, для поиска – NotFoundError и т.д.

Наши ошибки должны поддерживать базовые свойства, такие как message, name и, желательно, stack. Но также они могут иметь свои собственные свойства. Например, объекты HttpError могут иметь свойство statusCode со значениями 404, 403 или 500.

JavaScript позволяет вызывать throw с любыми аргументами, то есть технически наши классы ошибок не нуждаются в наследовании от Error. Но если использовать наследование, то появляется возможность идентификации объектов ошибок посредством obj instanceof Error. Так что лучше применять наследование.

По мере роста приложения, наши собственные ошибки образуют иерархию, например, HttpTimeoutError может наследовать от HttpError и так далее.

Практическое применение пользовательских исключений:
 - Прекращение выполнения операции при некорректных входных данных;
 - Бизнес-правила выявляют ошибки в ваших системах;
 - Интеграция с API сторонних сервисов требует обработки их специфических ошибок.

Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как err.cause

 - [https://learn.javascript.ru/custom-errors](https://learn.javascript.ru/custom-errors)
 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)
 - [https://habr.com/ru/companies/piter/articles/695890/](https://habr.com/ru/companies/piter/articles/695890/)

## 19. Promises, async/await и Event loop.

#### Promises

Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.

В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.

Что такое Promise?
`Promise` – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

На promise можно навешивать колбэки двух типов:

 - `onFulfilled` – срабатывают, когда promise в состоянии «выполнен успешно».
 - `onRejected` – срабатывают, когда promise в состоянии «выполнен с ошибкой».

Способ использования, в общих чертах, такой:

 - Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
 - Внешний код, получив promise, навешивает на него обработчики.
 - По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания Promise:

```javascript
var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически

  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})
```

Универсальный метод для навешивания обработчиков:

```javascript
promise.then(onFulfilled, onRejected)
```

 - `onFulfilled` – функция, которая будет вызвана с результатом при resolve.
 - `onRejected` – функция, которая будет вызвана с ошибкой при reject.

С его помощью можно назначить как оба обработчика сразу, так и только один:

```javascript
// onFulfilled сработает при успешном выполнении
promise.then(onFulfilled)
// onRejected сработает при ошибке
promise.then(null, onRejected)
```

`.catch` - Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.

Синхронный throw – то же самое, что reject.
Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:

```javascript
'use strict';

let p = new Promise((resolve, reject) => {
  // то же что reject(new Error("o_O"))
  throw new Error("o_O");
})

p.catch(alert); // Error: o_O
```

#### Async/await

Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования.

Асинхронные функции
Начнём с ключевого слова async. Оно ставится перед функцией, вот так:

```javascript
async function f() {
  return 1;
}
```

У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:

```javascript
async function f() {
  return 1;
}

f().then(alert); // 1
```

Можно и явно вернуть промис, результат будет одинаковым:

```javascript
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
```

Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – await, которое можно использовать только внутри async-функций.

**Await**

Синтаксис:

```javascript
// работает только внутри async–функций
let value = await promise;
```

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:

```javascript
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
```

В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.

Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку.

#### Event loop

Алгоритм событийного цикла:

 1. Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
 2. Исполнить все микрозадачи:
  * Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
 3. Отрисовать изменения страницы, если они есть.
 4. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
 5. Перейти к шагу 1.

Чтобы добавить в очередь новую макрозадачу:

 - Используйте setTimeout(f) с нулевой задержкой.

Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).

Для добавления в очередь новой микрозадачи:

 - Используйте queueMicrotask(f).

Также обработчики промисов выполняются в рамках очереди микрозадач.

События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.

 - [https://learn.javascript.ru/promise](https://learn.javascript.ru/promise)
 - [https://learn.javascript.ru/promise-basics](https://learn.javascript.ru/promise-basics)
 - [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

## 20. Основы сбора мусора.

Управление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции… Всё это занимает память.

#### Достижимость

Основной концепцией управления памятью в JavaScript является принцип достижимости.

Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

1. Существует базовое множество достижимых значений, которые не могут быть удалены.
  Например:
   - Выполняемая в данный момент функция, её локальные переменные и параметры.
   - Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
   - Глобальные переменные.
   - (некоторые другие внутренние значения)
  Эти значения мы будем называть корнями.
2. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
  Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.

В движке JavaScript есть фоновый процесс, который называется сборщиком мусора. Он отслеживает все объекты и удаляет те, которые стали недоступными.

#### Внутренние алгоритмы

Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

 - Сборщик мусора «помечает» (запоминает) все корневые объекты.
 - Затем он идёт по ним и «помечает» все ссылки из них.
 - Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
 - ...И так далее, пока не будут посещены все достижимые (из корней) ссылки.
 - Все непомеченные объекты удаляются.

Движки JavaScript применяют множество оптимизаций, чтобы она работала быстрее и не задерживала выполнение кода.

Вот некоторые из оптимизаций:

 - Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
 - Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
 - Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

Существуют и другие способы оптимизации и разновидности алгоритмов сборки мусора.

 - [https://learn.javascript.ru/garbage-collection](https://learn.javascript.ru/garbage-collection)
 - [https://habr.com/ru/articles/779186/](https://habr.com/ru/articles/779186/)
 - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_management](https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_management)

## 21. Понимание location браузера и history API.

#### Location

Интерфейс Location представляет собой адрес (URL) объекта, с которым он связан. Его модификации отражаются на родительском объекте. Интерфейсы Document и Window имеют подобный Location, к которому можно получить доступ через Document.location и Window.location соответственно.

**Свойства**

Интерфейс Location не имеет унаследованных свойств, но реализует свойства URLUtils.

`Location.href` DOMString, содержащий URL целиком. При изменении, соответствующий документ переходит на новую страницу.

`Location.protocol` DOMString, содержащий протокол текущего URL, включая ':'.

`Location.host` DOMString, содержащий хост, а именно имя хоста, ':' и порт.

`Location.hostname` DOMString, содержащий домен текущего URL.

`Location.port` DOMString, содержащий номер порта текущего URL.

`Location.pathname` DOMString, содержащий первый '/' после хоста с последующим текстом URL.

`Location.search` DOMString, содержащий '?' с последующими параметрами URL.

`Location.hash` DOMString, содержащий '#' с последующим идентификатором.

`Location.username` DOMString, содержащий имя пользователя, указанное перед именем домена.

`Location.password` DOMString, содержащий пароль, указанный перед именем домена.

`Location.origin` Только для чтения. Возвращает DOMString, содержащий протокол, хост и порт текущего URL.

**Методы**

Интерфейс Location не имеет унаследованных методов, но реализует методы URLUtils.

`Location.assign()` Загружает ресурс по URL, указанному в качестве параметра.

`Location.reload()` Перезагружает ресурс по текущему URL. Единственный опциональный параметр Boolean при значении true указывает, что страница должна быть заново загружена с сервера, при значении false страница может быть загружена из кеша.

`Location.replace()` Заменяет текущий ресурс на новый по URL, указанному в качестве параметра. Отличие от assign() в том, что при использовании replace() текущая страница не будет сохранена в History, и пользователь не сможет использовать кнопку назад, чтобы вернуться к ней.

`Location.toString()` Возвращает DOMString, содержащий URL целиком. Это синоним URLUtils.href, однако он не может использоваться для изменения значения.

#### History API

DOM-объект Window предоставляет доступ к истории текущей сессии браузера (не путать с историей браузерных расширений) через объект history. Он предоставляет полезные методы и свойства, которые позволяют переходить назад и вперёд по истории пользователя и манипулировать её содержимым.

**Понятия и использование**

Перемещение назад и вперёд по истории пользователя выполняется с помощью методов `back()`, `forward()`, и `go()`.

Перемещение вперёд и назад
Чтобы переместиться назад по истории:

```javascript
window.history.back();
```

Данный метод работает так, будто пользователь нажал на кнопку "Назад" на панели браузера. Похожим образом можно переместиться вперёд (как если бы пользователь нажал на кнопку "Вперёд"):

```javascript
window.history.forward();
```

Перемещение к определённой странице в истории. 
Вы можете использовать метод go() для загрузки конкретной страницы из истории сессии, определяемой её позицией относительно текущей страницы. Относительная позиция текущей страницы равняется 0.

Вернуться на одну страницу назад (равноценно вызову back()):

```javascript
window.history.go(-1);
```

Перейти на одну страницу вперёд (равноценно вызову forward())

```javascript
window.history.go(1);
```

По такому же принципу, можно перемещаться вперёд на 2 страницы, передавая аргумент 2, и так далее.

[https://developer.mozilla.org/ru/docs/Web/API/Location](https://developer.mozilla.org/ru/docs/Web/API/Location)
[https://developer.mozilla.org/ru/docs/Web/API/History_API](https://developer.mozilla.org/ru/docs/Web/API/History_API)

## 22. Анализ user-agent и определение платформы/браузера (объект navigator).

#### Navigator

Объект navigator предназначен для предоставления подробной информации о браузере, который пользователь использует для доступа к сайту или веб-приложению. Кроме данных о браузере, в нём ещё содержится сведения о операционной системе, сетевом соединении и др.

Объект navigator – это свойство window:

```javascript
const navigatorObj = window.navigator;
// или без указания window
// const navigatorObj = navigator;
```

Объект navigator имеет свойства и методы. Очень часто они используется для того чтобы узнать, какие функции поддерживаются браузером, а какие нет.

Свойства объекта navigator:

- `appCodeName` – кодовое имя браузера;
- `appName` – имя браузера;
- `appVersion` — версия браузера;
- `cookieEnabled` - позволяет определить включены ли cookie в браузере;
- `geolocation` - используется для определения местоположения пользователя;
- `language` - язык браузера;
- `online` - имеет значение true или false в зависимости от того находиться ли браузер в сети или нет;
- `platform` - название платформы, для которой скомпилирован браузер;
- `product` - имя движка браузера;
- `userAgent` - возвращает заголовок user agent, который браузер посылает на сервер.

Методы объекта navigator:

- `javaEnabled()` – позволяет узнать, включён ли в браузере Java;
- `sendBeacon()` - предназначен для отправки небольшого количества информации на веб-сервер без ожидания ответа.

#### User-Agent

Заголовок запроса User-Agent - это строка с характеристиками, по которым сервера и сетевые узлы могут определить тип приложения, операционную систему, производителя и/или версию пользовательского агента.

Пример содержания строки userAgent в браузере Google Chrome:

```
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36
```

Она содержит сведения об операционной системе, браузере, версиях, платформах и т.д.

Самый простой способ обнаружить мобильные устройства - это найти слово mobile в пользовательском агенте (userAgent):

```javascript
const isMobile = navigator.userAgent.toLowerCase().match(/mobile/i);

if (isMobile) {
  // для мобильных устройств
} else {
  // для не мобильных устройств
}
```

Более подробный вариант идентификации мобильного браузера:

```javascript
const isMobile = navigator.userAgent.toLowerCase().match(/mobile/i);
const isTablet = navigator.userAgent.toLowerCase().match(/tablet/i);
const isAndroid = navigator.userAgent.toLowerCase().match(/android/i);
const isiPhone = navigator.userAgent.toLowerCase().match(/iphone/i);
const isiPad = navigator.userAgent.toLowerCase().match(/ipad/i);
```

 - [https://itchief.ru/javascript/window-navigator](https://itchief.ru/javascript/window-navigator)
 - [https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/User-Agent](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/User-Agent)
 - [https://metanit.com/web/javascript/7.5.php](https://metanit.com/web/javascript/7.5.php)


## 23. Parsing, reflow, repaint и критический путь рендеринга.

### Синтаксический анализ

Анализ документа означает его преобразование в структуру, которую может использовать код. Результатом анализа обычно является дерево узлов, представляющих структуру документа. Это называется деревом разбора или синтаксическим деревом.

#### Грамматика

Синтаксический анализ основан на правилах синтаксиса, которым подчиняется документ: языке или формате, в котором он был написан. Каждый формат, который вы можете анализировать, должен иметь детерминированную грамматику, состоящую из словаря и правил синтаксиса. Это называется контекстно-свободной грамматикой.

#### Комбинация парсер-лексер

Синтаксический анализ можно разделить на два подпроцесса: лексический анализ и синтаксический анализ.

Лексический анализ — это процесс разбиения входных данных на токены. Токены — это словарь языка: набор действительных строительных блоков. В человеческом языке он будет состоять из всех слов, которые встречаются в словаре этого языка.

Синтаксический анализ – это применение правил синтаксиса языка.

Синтаксические анализаторы обычно делят работу между двумя компонентами: лексером (иногда называемым токенизатором), который отвечает за разбиение входных данных на действительные токены, и синтаксическим анализатором , который отвечает за построение дерева разбора путем анализа структуры документа в соответствии с правилами синтаксиса языка.

#### Перевод

Во многих случаях дерево разбора не является конечным продуктом. При переводе часто используется синтаксический анализ: преобразование входного документа в другой формат. Примером является компиляция. Компилятор, который компилирует исходный код в машинный код, сначала анализирует его в дерево синтаксического анализа, а затем преобразует это дерево в документ с машинным кодом.

#### HTML-парсер

Задача парсера HTML — преобразовать разметку HTML в дерево разбора (parse tree).

#### DOM

Выходное дерево («parse tree») представляет собой дерево элементов DOM и узлов атрибутов. DOM — это сокращение от объектной модели документа. Это объектное представление HTML-документа и интерфейс HTML-элементов с внешним миром, например JavaScript.

Корнем дерева является объект «Document».

#### CSS-парсер WebKit

WebKit использует генераторы анализаторов Flex и Bison для автоматического создания анализаторов из файлов грамматики CSS. Firefox использует парсер сверху вниз, написанный вручную. В обоих случаях каждый файл CSS анализируется в объект StyleSheet. Каждый объект содержит правила CSS. Объекты правил CSS содержат объекты селектора и объявления, а также другие объекты, соответствующие грамматике CSS.

#### Скрипты

Модель сети синхронна. Авторы ожидают, что скрипты будут анализироваться и выполняться немедленно, когда парсер достигнет тега `<script>` . Анализ документа останавливается до тех пор, пока скрипт не будет выполнен. Если скрипт является внешним, то ресурс сначала необходимо получить из сети — это также делается синхронно, и синтаксический анализ останавливается до тех пор, пока ресурс не будет получен. Эта модель использовалась на протяжении многих лет и также указана в спецификациях HTML4 и 5. Авторы могут добавить в скрипт атрибут «defer», и в этом случае он не остановит синтаксический анализ документа и будет выполнен после анализа документа. В HTML5 добавлена ​​возможность пометить сценарий как асинхронный, чтобы он анализировался и выполнялся в другом потоке.

#### Спекулятивный анализ
И WebKit, и Firefox выполняют такую ​​оптимизацию. Во время выполнения скриптов другой поток анализирует остальную часть документа, выясняет, какие еще ресурсы необходимо загрузить из сети, и загружает их. Таким образом, ресурсы можно загружать в параллельные соединения, а общая скорость повышается. Примечание. Спекулятивный парсер анализирует только ссылки на внешние ресурсы, такие как внешние скрипты, таблицы стилей и изображения: он не изменяет дерево DOM — это остается на усмотрение основного парсера.

#### Построение дерева рендеринга

Пока строится дерево DOM, браузер создает другое дерево — дерево рендеринга. Это дерево состоит из визуальных элементов в том порядке, в котором они будут отображаться. Это визуальное представление документа. Назначение этого дерева — обеспечить возможность раскрашивания содержимого в правильном порядке.

#### Компоновка (Layout/reflow)

Когда рендер создан и добавлен к дереву, он не имеет позиции и размера. Расчет этих значений называется lauout или reflow.

HTML использует модель layout на основе потока, что означает, что в основном геометрия вычисляется за один проход. Дочерние элементы обычно не влияют на геометрию родительских элементов, поэтому layout может пройтись слева направо, сверху вниз через документ. Существуют исключения: например, таблицы HTML могут потребовать более одного прохода.

Layout - это рекурсивный процесс. Он начинается с корневого рендеринга, который соответствует элементу `<html>` документа. Layout продолжается рекурсивно через дерево рендеринга, вычисляя геометрическую информацию для каждого рендера, для которого необходимо.

#### система "грязного бита"

Чтобы не делать reflow для каждого небольшого изменения, браузеры используют систему «грязного бита». Рендер, который изменяется или добавлен сам и его детей как «грязный» нуждается в перекомпоновке (reflow).

#### Отрисовка (painting)

На стадии отрисовки дерево рендеринга просматривается и вызывается метод рендеринга `Paint()` для отображения контента на экране. painting пользуется инфраструктурой UI.

#### Глобальный и постепенный

Как и компоновка, отрисовка также может быть глобальной (перерисовывается все дерево) - или постепенно. В постепенной отрисовке некоторые из рендеров меняются таким образом, что не влияют на все дерево.

#### Динамические изменения

Браузеры пытаются выполнить минимальные возможные действия в ответ на изменение. Таким образом, изменения в цвете элемента вызовут только перерисовку элемента. Изменения в позиции элемента приведут к перекомпоновке и перерисовке элемента, его детей и, возможно, братьев и сестер. Добавление узла DOM приведет к перекомпоновке и перерисовке узла. Основные изменения, такие как увеличение размера шрифта элемента, приведут к недействительности кэша, перекомпоновке и перерисовке всего дерева.

 - [https://web.dev/articles/howbrowserswork#scripts](https://web.dev/articles/howbrowserswork#scripts)
 - [https://developer.mozilla.org/ru/docs/Web/Performance/How_browsers_work](https://developer.mozilla.org/ru/docs/Web/Performance/How_browsers_work)
 - [https://habr.com/ru/articles/320430/](https://habr.com/ru/articles/320430/)
 - [https://developer.mozilla.org/ru/docs/Web/Performance/Critical_rendering_path](https://developer.mozilla.org/ru/docs/Web/Performance/Critical_rendering_path)

## 24. Использование «Fetch» ​​и понимание «XMLHTTPRequest».

### XMLHttpRequest

XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.

В современной веб-разработке XMLHttpRequest используется по трём причинам:

1. По историческим причинам: существует много кода, использующего XMLHttpRequest, который нужно поддерживать.
2. Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).
3. Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.

XMLHttpRequest имеет два режима работы: синхронный и асинхронный.

#### Асинхронный запрос.

Чтобы сделать запрос, нам нужно выполнить три шага:

1. Создать XMLHttpRequest.

```javascript
let xhr = new XMLHttpRequest(); // у конструктора нет аргументов
```

Конструктор не имеет аргументов.

2. Инициализировать его.

```javascript
xhr.open(method, URL, [async, user, password])
```
Этот метод обычно вызывается сразу после new XMLHttpRequest. В него передаются основные параметры запроса:

- `method` – HTTP-метод. Обычно это "GET" или "POST".
- `URL` – URL, куда отправляется запрос: строка, может быть и объект URL.
- `async` – если указать false, тогда запрос будет выполнен синхронно, это мы рассмотрим чуть позже.
- `user`, password – логин и пароль для базовой HTTP-авторизации (если требуется).

Заметим, что вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно отсылается запрос только лишь после вызова send.

3. Послать запрос.

```javascript
xhr.send([body])
```
Этот метод устанавливает соединение и отсылает запрос к серверу. Необязательный параметр body содержит тело запроса.

Некоторые типы запросов, такие как GET, не имеют тела. А некоторые, как, например, POST, используют body, чтобы отправлять данные на сервер. Мы позже увидим примеры.

4. Слушать события на xhr, чтобы получить ответ.

Три наиболее используемых события:

- `load` – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.
- `error` – когда запрос не может быть выполнен, например, нет соединения или невалидный URL.
- `progress` – происходит периодически во время загрузки ответа, сообщает о прогрессе.

```javascript
xhr.onload = function() {
  alert(`Загружено: ${xhr.status} ${xhr.response}`);
};

xhr.onerror = function() { // происходит, только когда запрос совсем не получилось выполнить
  alert(`Ошибка соединения`);
};

xhr.onprogress = function(event) { // запускается периодически
  // event.loaded - количество загруженных байт
  // event.lengthComputable = равно true, если сервер присылает заголовок Content-Length
  // event.total - количество байт всего (только если lengthComputable равно true)
  alert(`Загружено ${event.loaded} из ${event.total}`);
};
```

#### Тип ответа

Мы можем использовать свойство xhr.responseType, чтобы указать ожидаемый тип ответа:

- `""` (по умолчанию) – строка,
- `"text"` – строка,
- `"arraybuffer"` – ArrayBuffer (для бинарных данных, смотрите в ArrayBuffer, бинарные массивы),
- `"blob"` – Blob (для бинарных данных, смотрите в Blob),
- `"document"` – XML-документ (может использовать XPath и другие XML-методы),
- `"json"` – JSON (парсится автоматически).

#### Состояния запроса

У XMLHttpRequest есть состояния, которые меняются по мере выполнения запроса. Текущее состояние можно посмотреть в свойстве xhr.readyState.

Список всех состояний, указанных в спецификации:

```javascript
UNSENT = 0; // исходное состояние
OPENED = 1; // вызван метод open
HEADERS_RECEIVED = 2; // получены заголовки ответа
LOADING = 3; // ответ в процессе передачи (данные частично получены)
DONE = 4; // запрос завершён
```
Состояния объекта XMLHttpRequest меняются в таком порядке: `0 → 1 → 2 → 3 → … → 3 → 4`. Состояние 3 повторяется каждый раз, когда получена часть данных.

Изменения в состоянии объекта запроса генерируют событие `readystatechange`.

#### Отмена запроса

Если мы передумали делать запрос, можно отменить его вызовом `xhr.abort()`.

При этом генерируется событие `abort`, а `xhr.status` устанавливается в `0`.

#### Синхронный запрос.

Если в методе open третий параметр async установлен на false, запрос выполняется синхронно.

Другими словами, выполнение JavaScript останавливается на send() и возобновляется после получения ответа. Так ведут себя, например, функции alert или prompt.

Вот переписанный пример с параметром async, равным false:

```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/hello.txt', false);

try {
  xhr.send();
  if (xhr.status != 200) {
    alert(`Ошибка ${xhr.status}: ${xhr.statusText}`);
  } else {
    alert(xhr.response);
  }
} catch(err) { // для отлова ошибок используем конструкцию try...catch вместо onerror
  alert("Запрос не удался");
}
```

Выглядит, может быть, и неплохо, но синхронные запросы используются редко, так как они блокируют выполнение JavaScript до тех пор, пока загрузка не завершена.

#### HTTP-заголовки

XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.

Для работы с HTTP-заголовками есть 3 метода:

- `setRequestHeader(name, value)` Устанавливает заголовок запроса с именем name и значением value.
- `getResponseHeader(name)` Возвращает значение заголовка ответа name (кроме Set-Cookie и Set-Cookie2).
- `getAllResponseHeaders()` Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.

Между заголовками всегда стоит перевод строки в два символа `\r\n` (независимо от ОС), так что мы можем легко разделить их на отдельные заголовки. Значение заголовка всегда отделено двоеточием с пробелом `: `. Этот формат задан стандартом.

#### POST, FormData

Чтобы сделать POST-запрос, мы можем использовать встроенный объект FormData.

Синтаксис:

```javascript
let formData = new FormData([form]); // создаём объект, по желанию берём данные формы <form>
formData.append(name, value); // добавляем поле
```

Мы создаём объект, при желании указываем, из какой формы form взять данные, затем, если нужно, с помощью метода append добавляем дополнительные поля, после чего:

- `xhr.open('POST', ...)` – создаём POST-запрос.
- `xhr.send(formData)` – отсылаем форму серверу.

#### Прогресс отправки

Событие progress срабатывает только на стадии загрузки ответа с сервера.

Существует другой объект, без методов, только для отслеживания событий отправки: xhr.upload.

Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:

- `loadstart` – начало загрузки данных.
- `progress` – генерируется периодически во время отправки на сервер.
- `abort` – загрузка прервана.
- `error` – ошибка, не связанная с HTTP.
- `load` – загрузка успешно завершена.
- `timeout` – вышло время, отведённое на загрузку (при установленном свойстве timeout).
- `loadend` – загрузка завершена, вне зависимости от того, как – успешно или нет.

#### Запросы на другой источник

XMLHttpRequest может осуществлять запросы на другие сайты, используя ту же политику CORS, что и fetch.

Точно так же, как и при работе с fetch, по умолчанию на другой источник не отсылаются куки и заголовки HTTP-авторизации. Чтобы это изменить, установите `xhr.withCredentials` в `true`.

### Fetch

JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.

Для сетевых запросов из JavaScript есть широко известный термин «AJAX» (аббревиатура от Asynchronous JavaScript And XML)

Метод `fetch()` — современный и очень мощный, поэтому начнём с него. Он не поддерживается старыми (можно использовать полифил), но поддерживается всеми современными браузерами.

Базовый синтаксис:

```javascript
let promise = fetch(url, [options])
```

- `url` – URL для отправки запроса.
- `options` – дополнительные параметры: метод, заголовки и так далее.

Без options это простой GET-запрос, скачивающий содержимое по адресу url.

Процесс получения ответа обычно происходит в два этапа.

Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.

Мы можем увидеть HTTP-статус в свойствах ответа:

- `status` – код статуса HTTP-запроса, например 200.
- `ok` – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.

Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

- `response.text()` – читает ответ и возвращает как обычный текст,
- `response.json()` – декодирует ответ в формате JSON,
- `response.formData()` – возвращает ответ как объект FormData (разберём его в следующей главе),
- `response.blob()` – возвращает объект как Blob (бинарные данные с типом),
- `response.arrayBuffer()` – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
- `response.body` – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям.

#### Заголовки ответа

Заголовки ответа хранятся в похожем на Map объекте response.headers.

Это не совсем Map, но мы можем использовать такие же методы, как с Map, чтобы получить заголовок по его имени или перебрать заголовки в цикле:

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// получить один заголовок
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// перебрать все заголовки
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
```
#### Заголовки запроса

Для установки заголовка запроса в fetch мы можем использовать опцию headers. Она содержит объект с исходящими заголовками, например:

```javascript
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});
```

Есть список запрещённых HTTP-заголовков, которые мы не можем установить:

- `Accept-Charset`, `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`, `Cookie2`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- `Proxy-*`
- `Sec-*`

Эти заголовки обеспечивают достоверность данных и корректную работу протокола HTTP, поэтому они контролируются исключительно браузером.

#### POST-запросы

Для отправки POST-запроса или запроса с другим методом, нам необходимо использовать fetch параметры:

- `method` – HTTP метод, например POST,
- `body` – тело запроса, одно из списка:
  * строка (например, в формате JSON),
  * объект `FormData` для отправки данных как `form/multipart`,
  * `Blob`/`BufferSource` для отправки бинарных данных,
  * `URLSearchParams` для отправки данных в кодировке `x-www-form-urlencoded`, используется редко.

#### Отправка изображения

Мы можем отправить бинарные данные при помощи fetch, используя объекты `Blob` или `BufferSource`.

 - [https://learn.javascript.ru/xmlhttprequest](https://learn.javascript.ru/xmlhttprequest)
 - [https://learn.javascript.ru/fetch](https://learn.javascript.ru/fetch)
 - [https://learn.javascript.ru/fetch-progress](https://learn.javascript.ru/fetch-progress)
 - [https://habr.com/ru/articles/252941/](https://habr.com/ru/articles/252941/)

## 25. Различия между setTimeout и requestAnimationFrame.

Главное отличие от setTimeout() / setInterval() в том, что здесь вам не нужно указывать время, через которое функция запустится. requestAnimationFrame() работает гораздо эффективнее, учитывая частоту кадров и производительность системы.

 - [https://developer.mozilla.org/ru/docs/Web/Performance/CSS_JavaScript_animation_performance](https://developer.mozilla.org/ru/docs/Web/Performance/CSS_JavaScript_animation_performance)
 - [https://habr.com/ru/articles/260449/](https://habr.com/ru/articles/260449/)

## 26. Основные типы.

В TypeScript имеются следующие базовые типы:

- `boolean`: логическое значение `true` или `false`
- `number`: числовое значение
- `string`: строки
- `Array`: массивы
- `кортежи`
- `Enum`: перечисления
- `Any`: произвольный тип
- `Symbol`
- `null` и `undefined`: соответствуют значениям `null` и `undefined` в javascript
- `Never`: также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку

 - [https://habr.com/ru/companies/piter/articles/518428/](https://habr.com/ru/companies/piter/articles/518428/)
 - [https://scriptdev.ru/book/types/#_3](https://scriptdev.ru/book/types/#_3)
 - [https://typescript-handbook.ru/docs/ts-2](https://typescript-handbook.ru/docs/ts-2)

## 27. Перечисления.

Тип enum или перечисление позволяет определить набор именнованных констант, которые описывают определенные состояния.

Для определения перечисления применяется ключевое слово enum. Например, объявим следующее перечисление:

```typescript
enum Season { Winter, Spring, Summer, Autumn };
```

Перечисление называется Season и имеет четыре элемента.

### Числовые перечисления

По умолчанию константы перечисления, как в примере выше, представляют числовые значения. То есть это так называемое числовое перечисление, в котором каждой константе сопоставляется числовое значение.

### Строковые перечисления

Кроме числовых перечислений в TypeScript есть строковые перечисления, константы которых принимают строковые значения:

```typescript
enum Season { 
    Winter = "Зима", 
    Spring = "Весна",
    Summer = "Лето", 
    Autumn = "Осень"
};
var current: Season = Season.Summer;
console.log(current);   // Лето
```

### Смешанные гетерогенные перечисления

Также можно определять смешанные перечисления, константы которых могут числа и строки.

```typescript
enum Season { 
    Winter = 1, 
    Spring = "Весна",
    Summer = 3, 
    Autumn = "Осень"
};
var current: Season = Season.Summer;
console.log(current);           // 3
console.log(Season.Autumn);     // Осень
```

 - [https://metanit.com/web/typescript/2.11.php](https://metanit.com/web/typescript/2.11.php)
 - [https://scriptdev.ru/guide/015/](https://scriptdev.ru/guide/015/)

## 28. Тип/интерфейс, различия между ними.

Interface — это синтаксическая конструкция, предназначенная для описания открытой (public) части объекта без реализации (api).

В TypeScript интерфейс объявляется с помощью ключевого слова interface, после которого указывается идентификатор (имя), за которым следует тело, заключенное в фигурные скобки, содержащее описание.

```typescript
interface Identifier {
  // тело интерфейса
}
```

TypeScript предоставляет удобный синтаксис для указания имен описания типов, которые вы хотели бы использовать более чем в одном месте. Псевдонимы создаются с использованием синтаксиса `type SomeName = someValidTypeAnnotation`. 

```typescript
type StrOrNum = string | number;

// Использование: как и любая другая запись
var sample: StrOrNum;
sample = 123;
sample = '123';

// Просто проверяю
sample = true; // Ошибка!
```

### Interface для объектов, а Type для различных типов

Если мы рассмотрим вариант использования этих сущностей для объектов, то в ряде случаев они взаимно заменяемы. Рассмотрим пример:

```typescript
interface Interface1 {
    name: string;
}

type Type1 = {
    name: string;
}
```

В данном случае нет особой разницы, что использовать. Оба эти варианта подходят.

Однако, если мы будем говорить не об объектах, а о других сущностях, то тут не всё так однозначно. Для таких случаев мы должны использовать Type. Вот пара примеров:

```typescript
type Type2 = (prop: string) => string;

type Type3 = string;
```

### Расширение (extends) interface

Для interface существует такая функциональность, как расширение. Представим простой interface Animal, который будет обозначать животного:

```typescript
interface Animal {
    name: string;
}
```

У объекта, который реализует этот interface будет одно свойство - name. По сути, при желании мы можем назвать любое животной каким-то именем, так что это вполне оправдано.

Теперь рассмотрим расширение данного interface.

```typescript
interface Dog extends Animal {
    bark: () => void;
}
```

В данном случае мы создаём Interface Dog, который создаёт более конкретный тип животных - собак. И в нём мы реализуем метод bark - лай. Поскольку не все животные лают, а только собаки, то этот метод - специфическое свойство.

И давайте используем этот interface для создания объекта:

```typescript
const dog: Dog = {
    name: 'Бобик',
    bark: () => console.log('Гав')
}
```

Как вы увидели из данного примера, interface имеет возможность создания повых interface на основе предыдущих.

### Реализация (implements) interface

Поскольку interface - это сущность из ООП, то мы можем использовать её по назначению. Вот пример реализации:

```typescript
interface Human {
    name: string;
}

class Woman implements Human {
    sex: string = 'woman';
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
}
```

Тут мы создали interface Human, который обозначает человека. И мы создаём class Woman. В данном контексте ясно, что Human не должен быть class, ибо люди либо мужчины, либо женщины. В то же время, interface не ограничивает нас в множественном наследовании. Мы могли создать ещё несколько interface для class Woman.

В случае с type такое невозможно, так как они не связаны напрямую с ООП.

### Слияние интерфейсов

Интерфейсы поддерживают декларативное слияние, а псевдонимы типов нет. Объявив два или более интерфейса с одинаковыми идентификаторами (именами), мы получим один общий интерфейс:

```typescript
interface Order {
  id: string;
  createdAt: Date;
  items: string[];
}

interface Order {
  status: string;
}

interface Order {
  owner: string;
}

const myOrder: Order = {
  id: '31337',
  createdAt: new Date(),
  items: ['orange', 'banana'],
  status: 'created',
  owner: 'Michael Jackson',
}
```

### Типы пересечения

При разработке на TypeScript часто возникает необходимость комбинировать различные типы. Один из вариантов комбинации — пересечение типов. Результатом пересечения становится тип с общими характеристиками типов, участвующих в пересечении.

В TypeScript эту задачу решает оператор амперсанд (&). Рассмотрим на примере.

```typescript
type OrderIdentifier = {
  id: string;
}

type OrderStatus = {
  status: string;
}

type Order = OrderIdentifier & OrderStatus;
```

За счёт пересечения мы получаем новый тип Order. Он объединяет общие характеристики типов OrderIdentifier и OrderStatus. Получить новый тип пересечения возможно и на основании интерфейсов:

```typescript
interface OrderIdentifier {
  id: string;
}

interface OrderStatus {
  status: string;
}

type Order = OrderIdentifier & OrderStatus;
```

Результат выполнения этого кода не отличается от предыдущего. Однако, при объединении интерфейсов мы получаем тип пересечения Order. Обратите внимание, мы получаем именно тип пересечения, а не интерфейс. Получить новый интерфейс пересечения не получится. Это ещё одно отличие между type и interface.

### Типы объединения

Псевдонимы типов можно объединять. В результате объединения получается новый тип. Новый тип содержит всё что есть в типах, участвующих в объединении. Для объединения применяется оператор |. Рассмотрим на примере:

```typescript
type Dog = {
  bark: () => void;
}

type Cat = {
  meow: () => void;
}

type Animal = Dog | Cat;

// Собака Гуффи
const goofy: Dog = {
  bark() {
    console.log('bark');
  }
}

// Кот Том
const tom: Cat = {
  meow() {
    console.log('meow');
  }
}


// Animal подойдёт для кошек
let animal: Animal = tom;

//  и для собак
animal = goofy;
```

Объединять можно не только псевдонимы, но и интерфейсы. Принцип тот же, что и при пересечении. Результатом станет новый псевдоним типа, объединяющий интерфейсы. Получить новый интерфейс в результате объединения не получится.

 - [https://habr.com/ru/sandbox/186102/](https://habr.com/ru/sandbox/186102/)
 - [https://htmlacademy.ru/blog/js/types-vs-interfaces](https://htmlacademy.ru/blog/js/types-vs-interfaces)

## 29. Использование интерфейсов с необязательными свойствами, свойствами только для чтения и т. д.

### Необязательные свойства и свойства только для чтения

При определении интерфейса мы можем задать некоторые свойства как необязательные с помощью знака вопроса. Подобные свойства реализовать необязательно:

```typescript
interface IUser {
    id: number;
    name: string;
    age?: number;
}
let employee: IUser = {
     
    id: 1, 
    name: "Alice",
    age: 23
}
let manager: IUser = {
     
    id: 2, 
    name: "Tom"
}
```

Свойство age помечено как необязательное, поэтому его можно не определять в объектах.

Также интерфейс может содержать свойства только для чтения, значение которых нельзя изменять. Такие свойства определяются с помощью ключевого слова readonly:

```typescript
interface Point {
    readonly x: number;
    readonly y: number;
}
let p: Point = { x: 10, y: 20 };
console.log(p);
// p.x = 5; // Ошибка - свойство доступно только для чтения
```

### Определение методов

Кроме свойств интерфейсы могут определять функции:

```typescript
interface IUser {
    id: number;
    name: string;
    sayWords(words: string): void;
}
let employee: IUser = {
      
    id: 1, 
    name: "Alice",
    sayWords: function(words: string): void{
        console.log(`${this.name} говорит "${words}"`);
    }
}
  
employee.sayWords("Привет, как дела?");
```

Опять же объект, который реализует интерфейс, также обязан реализовать определенную в интерфейсе функцию с тем же набором параметров и тем типом выходного результата. В данном случае функция sayWords() в качестве параметра принимает строку и ничего возвращает, выводя на консоль некоторое сообщение.

 - [https://metanit.com/web/typescript/3.3.php](https://metanit.com/web/typescript/3.3.php)

## 30. Типы функций.

### Тип функции

Каждая функция имеет тип, как и обычные переменные. Тип функции фактически представляет комбинацию типов параметров и типа возвращаемого значения. В общем виде определение типа функции выглядит следующим образом:

```typescript
(параметр1: тип, параметр2: тип,...параметрN: тип) => тип_результата;
```

В скобках идет перечисление через запятую параметров и их типов. После списка параметров через оператор => указывается тип возвращаемого функцией результата.

Также мы можем определять значения этого типа функции:

```typescript
let op: (x:number, y:number) => number;
```

То есть переменная op представляет любую функцию, которая принимает два числа и которая возвращает число.

Функции как параметры других функций
Тип функции можно использовать как тип переменной, но он также может применяться для определения типа параметра другой функции:

```typescript
function sum (x: number, y: number): number {
    return x + y;
};
function multiply (a: number, b: number): number {
    return a * b;
};
  
function mathOp(x: number, y: number, op: (a: number, b: number) => number): number{
  
    return op(x, y);
}
console.log(mathOp(10, 20, sum)); // 30 
console.log(mathOp(10, 20, multiply)); // 200
```

Если определенный тип функции предстоит очень часто использовать, то для него оптимальнее определить псевдоним и обращаться к типу по этому псевдониму:

```typescript
type Operation = (a: number, b: number) => number;
 
function mathOp(x: number, y: number, op: Operation): number{
  
    return op(x, y);
}
const sum: Operation = function(x: number, y: number): number {
    return x + y;
};
 
console.log(mathOp(10, 20, sum)); // 30
```

 - [https://metanit.com/web/typescript/2.3.php](https://metanit.com/web/typescript/2.3.php)
 - [https://scriptdev.ru/guide/020/](https://scriptdev.ru/guide/020/)

## 31. Utility types `(необязательно)`.

TypeScript Utility Types - это набор встроенных типов, которые можно использовать для манипулирования типами данных в коде. Рассмотрим их подробнее.

### Awaited

`Awaited<T>` - это специальный тип, который может быть использован для обозначения типа, который будет возвращен из асинхронной функции.

```typescript
async function getData(): Promise<string> {
    return 'hello';
}

let awaitedData: Awaited<ReturnType<typeof getData>>;
// теперь awaitedData может быть 'hello'
```

### Partial

`Partial<T>` - делает все свойства объекта типа T необязательными.

```typescript
interface Person {
  name: string;
  age: number;
}

let partialPerson: Partial<Person>;
// теперь partialPerson может быть { name?: string; age?: number; }
```

### Required

`Required<T>` - делает все свойства объекта типа T обязательными.

```typescript
interface Person {
  name?: string;
  age?: number;
}

let requiredPerson: Required<Person>;
// теперь requiredPerson может быть { name: string; age: number; }
```

### Readonly

`Readonly<T>` - делает все свойства объекта типа T доступными только для чтения.

```typescript
interface Point {
  x: number;
  y: number;
}

let readonlyPoint: Readonly<Point>;
// теперь readonlyPoint может быть { readonly x: number; readonly y: number; }
```

### Record

`Record<Keys, Type>` - создает тип, который является записью с ключами, определенными в первом параметре, и значениями типа, определенного во втором параметре.

```typescript
type Keys = 'a' | 'b' | 'c';
type RecordType = Record<Keys, number>;

let record: RecordType;
// теперь record может быть { a: number, b: number, c: number }
```

### Pick

`Pick<T, K extends keyof T>` - выбирает свойства объекта типа T с ключами, указанными в K.

```typescript
interface Person {
  name: string;
  age: number;
}

let pickedPerson: Pick<Person, 'name'>;
// теперь pickedPerson может быть { name: string; }
```

### Omit

`Omit<T, K extends keyof T>` - выбирает свойства объекта типа T, исключая те, которые указаны в K

```typescript
interface Person {
  name: string;
  age: number;
}

let omittedPerson: Omit<Person, 'age'>;
// теперь omittedPerson может быть { name: string; }
```

### Exclude

`Exclude<UnionType, ExcludedMembers>` - исключает определенные типы из объединенного типа.

```typescript
type A = 'a' | 'b' | 'c';
type B = Exclude<A, 'a' | 'b'>;
// теперь B это 'c'
```

### Extract

`Extract<Type, Union>` - извлекает из типа Type только те типы, которые присутствуют в Union.

```typescript
type A = 'a' | 'b' | 'c';
type B = 'a' | 'b';
type C = Extract<A, B>;
// теперь C это 'a' | 'b'
```

### NonNullable

`NonNullable<Type>` - извлекает тип из Type, исключая null и undefined.

```typescript
let value: string | null | undefined;
let nonNullableValue: NonNullable<typeof value>;
// теперь nonNullableValue это string
```

### Parameters

`Parameters<Type>` - извлекает типы аргументов функции Type.

```typescript
function foo(a: string, b: number) {}
type FooParameters = Parameters<typeof foo>;
// теперь FooParameters это [string, number]
```

### ConstructorParameters

`ConstructorParameters<Type>` - извлекает типы аргументов конструктора Type.

```typescript
class Foo {
    constructor(a: string, b: number) {}
}
type FooConstructorParameters = ConstructorParameters<typeof Foo>;
// теперь FooConstructorParameters это [string, number]
```

### ReturnType

`ReturnType<Type>` - извлекает тип возвращаемого значения функции Type.

```typescript
function foo(): string { return 'hello'; }
type FooReturnType = ReturnType<typeof foo>;
// теперь FooReturnType это string
```

### InstanceType

`InstanceType<Type>` - извлекает тип экземпляра класса Type.

```typescript
class Foo { x: number }
type FooInstance = InstanceType<typeof Foo>;
// теперь FooInstance это { x: number }
```

### ThisParameterType

`ThisParameterType<Type>` - извлекает тип this из функции Type.

```typescript
class Foo {
    x: number;
    method(this: this): void { }
}
type ThisType = ThisParameterType<Foo["method"]>;
// теперь ThisType это Foo
```

### OmitThisParameter

`OmitThisParameter<Type>` - определяет функцию без типа this.

```typescript
class Foo {
    x: number;
    method(this: this): void { }
}
type MethodType = OmitThisParameter<Foo["method"]>;
// теперь MethodType это () => void
```

### ThisType

`ThisType<Type>` - добавляет тип this к функции Type.

```typescript
class Foo {
    x: number;
    method(): void { }
}
type MethodType = ThisType<Foo["method"]>;
// теперь MethodType это (this: Foo) => void
```

### Управление регистром

`Uppercase<StringType>`, `Lowercase<StringType>`, `Capitalize<StringType>`, `Uncapitalize<StringType>` - это утилитные типы для манипуляции строками, которые изменяют регистр строки в соответствии с их именем.

```typescript
type Uppercased = Uppercase<'hello'>; // 'HELLO'
type Lowercased = Lowercase<'Hello'>; // 'hello'
type Capitalized = Capitalize<'hello'>; // 'Hello'
type Uncapitalized = Uncapitalize<'Hello'>; // 'hello'
```
 - [https://habr.com/ru/articles/711686/](https://habr.com/ru/articles/711686/)
 - [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)

## 32. Type guards `(необязательно)`.

Защитники типа (Type Guards) — это правила, которые помогают выводу типов определить суженный диапазон типов для значения, принадлежащего к типу Union. Другими словами, разработчику предоставлен механизм, позволяющий с помощью выражений составить логические условия, проанализировав которые, вывод типов сможет сузить диапазон типов до указанного и выполнить над ним требуемые операции.

### Сужение диапазона множества типов на основе типа данных

При необходимости составления условия, в основе которого лежат допустимые с точки зрения JavaScript типы, прибегают к помощи уже знакомых операторов typeof и instanceof.

К помощи оператора typeof прибегают тогда, когда хотят установить принадлежность к типам number, string, boolean, object, function, symbol или undefined. Если значение принадлежит к производному от объекта типу, то установить его принадлежность к типу, определяемого классом и находящегося в иерархии наследования, можно при помощи оператора instanceof.

Как уже было сказано, с помощью операторов typeof и instanceof составляется условие, по которому компилятор может вычислить, к какому конкретно типу или диапазону будет относиться значение в определяемой условием области.

```typescript
// Пример для оператора typeof

type ParamType =
  | number
  | string
  | boolean
  | object
  | Function
  | symbol
  | undefined;

function identifier(param: ParamType): void {
  param; // param: number | string | boolean | object | Function | symbol | undefined

  if (typeof param === 'number') {
    param; // param: number
  } else if (typeof param === 'string') {
    param; // param: string
  } else if (typeof param === 'boolean') {
    param; // param: boolean
  } else if (typeof param === 'object') {
    param; // param: object
  } else if (typeof param === 'function') {
    param; // param: Function
  } else if (typeof param === 'symbol') {
    param; // param: symbol
  } else if (typeof param === 'undefined') {
    param; // param: undefined
  }

  param; // param: number | string | boolean | object | Function | symbol | undefined
}
```

```typescript
// Пример для оператора instanceof

class Animal {
  constructor(public type: string) {}
}

class Bird extends Animal {}
class Fish extends Animal {}
class Insect extends Animal {}

function f(param: Animal | Bird | Fish | Insect): void {
  param; // param: Animal | Bird | Fish | Insect

  if (param instanceof Bird) {
    param; // param: Bird
  } else if (param instanceof Fish) {
    param; // param: Fish
  } else if (param instanceof Insect) {
    param; // param: Insect
  }

  param; // param: Animal | Bird | Fish | Insect
}
```

### Сужение диапазона множества типов на основе признаков, присущих типу Tagged Union

Помимо определения принадлежности к единичному типу, диапазон типов, составляющих тип Union, можно сузить по признакам, характерным для типа Tagged Union.

Условия, составленные на основе идентификаторов варианта, можно использовать во всех условных операторах, включая switch.

```typescript
// Пример для оператора if/else

enum AnimalTypes {
  Animal = 'animal',
  Bird = 'bird',
  Fish = 'fish',
}

class Animal {
  readonly type: AnimalTypes = AnimalTypes.Animal;
}

class Bird extends Animal {
  readonly type: AnimalTypes.Bird = AnimalTypes.Bird;

  public fly(): void {}
}

class Fish extends Animal {
  readonly type: AnimalTypes.Fish = AnimalTypes.Fish;

  public swim(): void {}
}

function move(param: Bird | Fish): void {
  param; // param: Bird | Fish

  if (param.type === AnimalTypes.Bird) {
    param.fly();
  } else {
    param.swim();
  }

  param; // param: Bird | Fish
}
```

### Сужение диапазона множества типов на основе доступных членов объекта

Сужение диапазона типов также возможно на основе доступных (public) членов, присущих типам, составляющим диапазон (Union). Сделать это можно с помощью оператора in.

```typescript
class A {
  public a: number = 10;
}
class B {
  public b: string = 'text';
}
class C extends A {}

function f0(p: A | B) {
  if ('a' in p) {
    return p.a; // p: A
  }

  return p.b; // p: B
}

function f1(p: B | C) {
  if ('a' in p) {
    return p.a; // p: C
  }

  return p.b; // p: B
}
```

 - [https://scriptdev.ru/guide/036/#-](https://scriptdev.ru/guide/036/#-)
 - [https://medium.com/@eqbits/что-такое-type-guards-в-typescript-24834d2b4f](https://medium.com/@eqbits/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-type-guards-%D0%B2-typescript-24834d2b4f)

## 33. Создание пользовательских типов.

TypeScript позволяет создавать кастомные типы, используя так называемые псевдонимы типов. Основное различие между ними и интерфейсами в том, что при использовании псевдонима мы создаём новое имя для типа, а интерфейс создаёт новое имя для формы объекта.

Например, псевдоним типа можно использовать, чтобы создать собственный тип для точки в двухмерном пространстве:

```typescript
type Point = { x: number, y: number };
let point: Point = { x: 0, y: 0 };
```

С помощью псевдонимов типов также можно создавать сложные типы вроде объединённого типа или типа пересечения.

```typescript
type User = { name: string, age: number };
type Admin = { name: string, age: number, privileges: string[] };
type SuperUser = User & Admin;
```

 - [https://habr.com/ru/companies/ruvds/articles/712548/](https://habr.com/ru/companies/ruvds/articles/712548/)


## 34. Дженерики (концепция).

Дженерики позволяют писать более универсальный код, способный работать с любым типом. С их помощью можно написать одну функцию, класс либо интерфейс, работающие с несколькими типами.

К примеру, обобщённую функцию можно использовать для создания массива любого типа:

```typescript
function createArray<T>(length: number, value: T): Array<T> {
 let result = [];
 for (let i = 0; i < length; i++) {
 result[i] = value;
 }
 return result;
}
let names = createArray<string>(3, "Bob");
let numbers = createArray<number>(3, 0);
```

С помощью дженериков также можно создать класс, способный работать с любым типом данных:

```typescript
class GenericNumber<T> {
 zeroValue: T;
 add: (x: T, y: T) => T;
}
let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

 - [https://habr.com/ru/companies/ruvds/articles/712548/](https://habr.com/ru/companies/ruvds/articles/712548/)
 - [https://scriptdev.ru/book/types/#_7](https://scriptdev.ru/book/types/#_7)

## 35. Понимание системы модулей в ES6 и TypeScript.

По умолчанию эта система модулей совместима с Node.js-модулями. Она использует идентичный алгоритм определения импортов и экспортов, при этом синтаксически похожа на ESM. В нем мы используем ключевые слова import/export для импортирования в текущий модуль и экспорта из него, при этом остается валидным использование CommonJS модулей.

Для примера создадим два файла. Из одного будем экспортировать функцию, а в другом импортировать ее:

```typescript
// @file helloWorld.ts
export default function helloWorld() {
  console.log("Hello, world!");
}

// @file main.ts
import helloWorld from './helloWorld';
```

В системе модулей TypeScript также поддерживается именованный экспорт/импорт и импорт всего экспортированного через import * as:

```typescript
// @file helloWorld
export function helloWorld() {}
export function helloWorldAgain() {}

// @file main
import { helloWorld, helloWorldAgain } from './helloWorld';

// @file next
import * as hw from './helloWorld';
hw.helloWorld();
```

Импорт типов
TypeScript также как и JavaScript использует npm-пакеты для зависимостей. При этом важно помнить, что в некоторых пакетов типов может и не быть. Например, в пакете lodash нет типов, поэтому при импорте его функций TypeScript будет ругаться на отсутствие типов.

Для решения этой проблемы нужно установить пакет @types/lodash, который содержит типы для lodash.

Но верна и обратная ситуация, например, пакет type-fest содержит только типы. Чтобы создать такой пакет самому и случайно не импортировать реализацию функций, нужно использовать специальный синтаксис:

```typescript
// @file user.types.ts
export type User = { name: string };

// @file main.ts
import type { User } from './user.types';
```

Пространство имен (Namespace)
Модули решают проблему разнородных сущностей и коллизий с помощью разнесения кода по нескольким файлам. Чтобы коллизии не возникали в рамках одного файла, используют механизм пространств имен namespace:

```typescript
namespace Hello {
  export function helloWorld() {
      console.log("Hello, world!");
  }
}
```

const helloWorld = Hello.helloWorld();
Больше всего этот механизм полезен авторам библиотек и оберток с типами @types/. Они заключают все интерфейсы в один namespace, совпадающий с названием библиотеки. Это гарантирует отсутствие коллизий имен и упрощает пользователям слияние интерфейсов

 - [https://code-basics.com/ru/languages/typescript/lessons/modules](https://code-basics.com/ru/languages/typescript/lessons/modules)
 - [https://habr.com/ru/companies/macloud/articles/563722/](https://habr.com/ru/companies/macloud/articles/563722/)

## 36. Знакомство с паттернами порождающие, структурные и поведенческие.

**Паттерн проектирования** — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.

Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. Проводя аналогию со строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — идиомы. Они не универсальны, поскольку применимы только в рамках одного языка программирования.

Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

Кроме того, паттерны отличаются и предназначением:

 - Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
 - Структурные паттерны показывают различные способы построения связей между объектами.
 - Поведенческие паттерны заботятся об эффективной коммуникации между объектами.

 -[https://refactoring.guru/ru/design-patterns/classification](https://refactoring.guru/ru/design-patterns/classification)

## 37. Принципы SOLID и паттерны проектирования в контексте проекта.

### S – Single Responsibility (Принцип единственной ответственности)

Каждый класс должен отвечать только за одну операцию.

### O — Open-Closed (Принцип открытости-закрытости)

Классы должны  быть  открыты для расширения, но закрыты для модификации.

### L — Liskov Substitution (Принцип подстановки Барбары Лисков)

Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

### I — Interface Segregation (Принцип разделения интерфейсов)

Не следует ставить клиент в зависимость от методов, которые он не использует.

### D — Dependency Inversion (Принцип инверсии зависимостей)

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

 - [https://habr.com/ru/companies/productivity_inside/articles/505430/](https://habr.com/ru/companies/productivity_inside/articles/505430/)

## 38. Методологии Agile, Scrum, Kanban и Waterfall.

### Waterfall – каскадная модель
Каскадная модель или модель «водопад», – это вариант классического поэтапного планирования. 

Проект состоит из последовательных этапов: инициация, планирование, разработка, реализация и тестирование, мониторинг и завершение. 

![alt text](image-3.png)

**Инициация**. Руководитель проекта и команда определяют требования к проекту: проводят совещания, мозговые штурмы, интервью. На них обозначают, какой результат хотят получить в итоге. 

**Планирование**. Команда уточняет и детализирует цели проекта и состав работ по нему. Затем формирует календарный план и бюджет, оценивает риски.

**Разработка**. Участники определяют конфигурацию будущего проекта и технические способы ее достижения. Например, делают модель здания.

**Реализация и тестировани**е. На этой фазе происходит основная работа – строители закладывают фундамент, возводят стены и крышу, проводят коммуникации. 

**Мониторинг и завершение проекта**. Руководитель передает проект клиенту, оценивает результат и составляет план по улучшению на будущее.

Разным проектам нужны различные этапы реализации – некоторым достаточно и трех фаз, другим нужно больше пяти. Но суть waterfall-модели одна – проект разбит на этапы, которые заранее запланированы и выполняются один за другим.

### Agile – гибкое управление проектом.

Agile – это система ценностей, помогающая создавать новые продукты. 
Agile появился, когда стало понятно, что традиционное управление неэффективно в проектах с постоянно меняющимися условиями: 
 - для разработки новых технологий,
 - тестирования новых продуктов,
 - выхода на новый рынок. 

Сам по себе Agile – это не модель управления, а философия, помогающая сформировать отношение к работе. Философия состоит из четырех ценностей и 12 принципов. 

[Agile-манифест](https://agilemanifesto.org/iso/ru/manifesto.html)

Особенности Agile

**Полностью самоорганизующаяся команда.** Команда Agile – это небольшая работающая над одним проектом группа людей, в составе которой уже есть все необходимые для этого специалисты. В команде нет руководителей и подчиненных и роли за участниками не закреплены: разработчик может тестировать, аналитик предлагать идеи для дизайна.
Разработка небольшими итерациями. Продукт или проект разбивается на ценные части, каждая из которых разрабатывается в отдельный временной промежуток –  итерацию . За один такой интервал времени разрабатывают новую версию продукта или перерабатывают уже существующий. В итоге после итерации получается новый продукт или новая версия, готовая к выпуску. Продукт выпускают, собирают обратную связь и в следующую итерацию улучшают и дорабатывают. Иногда итерации называют agile-спринтами, но это не совсем верно. Спринт – термин из Scrum-подхода.

**Можно менять проект в процессе.** И заказчик, и команда оценивают результат по ходу проекта и решают, как действовать дальше.

**Результат важнее документации.** От плана можно отступать, если это принесет пользу проекту.

![alt text](image-2.png)

### Scrum – инструкция по запуску нового продукта

Scrum  – это способ организации рабочего процесса. Скрам помогает проверять идеи, тестировать новые решения, выпускать инновационные продукты.

В методологиях, моделях, системах управления проектами легко запутаться. Может показаться, что скрам и аджайл – это одно и то же, но это не так. Можно сказать, что аджайл – это конституция с основными принципами, а скрам – это кодекс с конкретными инструкциями. У скрама узкая область применения, к нему обращаются, когда классические техники управления проектами неэффективны. Принципы гибкой методологии разработки Scrum основаны на философии Agile.

Особенности Scrum-подхода
 - **Возможность разработать новый продукт.** Скрам хорошо подходит, когда неизвестно, нужен ли пользователям такой продукт. Вы выпускаете пробный вариант, обучаетесь с помощью обратной связи и делаете следующую версию.
 - **Фокусировка на пользе для потребителя.** Методология Scrum и agile-принципы заточены на то, чтобы изучать потребности пользователей, улучшать их опыт использования продукта. А не на то, чтобы сделать продукт в срок и согласовать его с заказчиком. 
 - **Возможность менять продукт.** Работая короткими циклами, можно предлагать пользователям продукты почти по требованию и быстро адаптироваться к новым условиям.
 - **Снижение риска за счет тестирования.** Скрам позволяет быстро выпустить тестовый вариант продукта, оценить его работоспособность и затем приступить к доработке. Это снижает риски провала по сравнению с подходом, когда продукт бесконечно шлифуется до запуска.
 - **Вовлеченные сотрудники.** Команда вовлекается в работу, потому что она работает только над одним проектом и видит результат от своих усилий.

![image](image.png)

Kanban – инструменты для улучшения рабочих процессов
Kanban  – это метод для построения внутренних процессов в компании. Он тоже входит в семейство гибких методологий. Канбан – это также один из инструментов бережливого производства. Но мы рассматриваем канбан не как часть бережливого производства, а как метод гибкого управления.

Канбан помогает визуализировать процесс работы. Все задачи, которые команда делает или планирует сделать, вывешиваются на **доску**.

![alt text](image-1.png)

Доска может быть как физической, так и виртуальной, например, Trello. Важно, чтобы задачи не были слишком маленькими – так их будет много и учет будет отнимать время. Также важно, чтобы задачи не были слишком большими, чтобы карточки не застревали на доске.

Важный момент – это точка принятия обязательств. Если задача правее этой точки, команда еще решает, делать или не делать эту задачу. Но когда задача перемещается левее, это значит, что задачу решили сделать. С момента, как задачу решили сделать, имеет смысл отслеживать прогресс по ней. 

Чем дальше задача продвигается по доске, тем ценнее она становится – на нее уже потратили время и деньги. Например, задача, которая стоит на приемке, будет приоритетнее, чем задача, которую только начали делать, потому что она почти готова и от нее быстрее можно получить пользу.  

Поэтому в канбане есть принцип «перестаньте начинать [новые задачи], начните завершать [задачи, которые уже в работе]»
Задача визуализации  – сбалансировать разных специалистов внутри команды и избежать ситуации, когда разработчики работают сутками, а тестировщики жалуются на отсутствие новых задач.

Доска – это лишь один из инструментов, который помогает увидеть проблемы. Чтобы оптимизировать работу, существуют другие инструменты: ограничение количества задач в работе, управление потоком,  каденции  и так далее.

**Особенности канбана**

Канбан предлагает оценивать эффективность с точки зрения сервиса: насколько заказчик остался доволен, с какими задачами обычно обращаются клиенты, сколько они готовы ждать.

Главный показатель эффективности в Kanban – это среднее время прохождения задачи по доске. Если задача прошла быстро – все хорошо. Если время выполнения затянулось, нужно думать, где и почему возникли проблемы.

Чтобы повысить эффективность, в канбане ограничивают количество задач, находящихся в работе. Например, дизайнер может работать над тремя задачами. Пока он не закончит одну из задач, он не может взять новую. Это помогает работать спокойнее и быстрее заканчивать текущие задачи. 

Вся команда едина – нет ролей владельца продукта и scrum-мастера. Бизнес-процесс делится не на универсальные спринты, а на стадии выполнения конкретных задач: «Сделать», «В процессе», «Тестирование», «Согласование» и др.

**Ограничения канбана**

У канбана широкая область применения. Можно сравнить его с ящиком инструментов. Для каждой задачи можно что-то подобрать. При этом каждый будет пользоваться инструментами по-своему. Поэтому канбан можно применить везде, где у вас есть поток задач. Однако, метод будет неэффективен, если нужно разработать новый сложный продукт, для этого лучше подойдет скрам.

**Канбан подойдет:**

если у команды много задач и заказов: канбан поможет выявить проблемы и оптимизировать работу;

для отделов, которые поддерживают операционную деятельность: бухгалтерия, финансовый отдел;

для визуализации процессов и выявления проблем: доску по канбан-методу можно вести даже для личных дел – чтобы видеть приоритетные задачи и заметить дело, которое уже давно висит. 

![alt text](image-4.png)

 - [https://kachestvo.pro/kachestvo-upravleniya/proektnoe-upravlenie/agile-scrum-waterfall-i-kanban-dlya-upravleniya-proektami-v-kompanii/](https://kachestvo.pro/kachestvo-upravleniya/proektnoe-upravlenie/agile-scrum-waterfall-i-kanban-dlya-upravleniya-proektami-v-kompanii/)

## 39. Методы оценки проекта.

### Что такое оценка проекта

Это способ определения вероятностей достижения поставленных целей и задач по проекту. При объективной и достоверной оценке можно определить реальный статус проекта на каждом этапе. А именно: все ли идет по плану; нужны ли дополнительные инструменты и ресурсы; соответствует ли работа запланированному результату и так далее.

### Методы оценки проекта

Существует множество методов, с помощью которых можно оценить проект. Выбор конкретного метода зависит от специфики реализации конкретной идеи и, конечно, предпочтений заказчика. Далее подробнее рассмотрим каждый из них:

**Экспертная оценка** – наиболее распространенный качественный метод, причем используется не только в проектном подходе. Бывает индивидуальная экспертная оценка, когда привлекается один конкретный специалист с опытом реализации в похожих проектах. Также можно осуществить коллективную оценку, организовав собрание или совет участников проекта, отвечающих за разные его области. Здесь каждый член команды представляет свои предположения по сложности, продолжительности реализации работ или другим оцениваемым параметрам, а руководитель собирает и систематизирует эти выводы, выстраивая при этом общий график или систему действий.

**PERT (Program Evaluation Review Technique)** – уже количественный метод, применяемый при оценке реализации отдельных задач. С его помощью можно определить конкретное время на выполнение каждого этапа проекта. Подходит только для общей оценки, при более детальном анализе такой способ будет чрезмерно трудоемким и даже ошибочным. По этой причине не рекомендуется использовать его для расчета непродолжительных задач. На основе этого метода можно рассчитать как оптимистичный, так и пессимистичный исходы, используя при этом следующие формулы:
![alt text](image-5.png)
Где:

О – оптимистичная оценка, когда задачи выполняются строго по плану, а риски учтены и возникнуть не должны.

Р – реалистичная оценка, когда выполнение задач учитывается с учетом возможных рисков, не имеющих серьезного воздействия на продолжительность проекта.

П – пессимистическая оценка, когда учитывается вероятность возникновения средних и серьезных рисков, из-за которых можно значительно перенести сроки.

### Инструменты для оценки

 - Иерархия задач
 - Покер планирования
 - Голосование по точкам

### Этапы оценки проекта
Чтобы в процессе реализации проекта не упустить важные детали, требуется проводить его оценку на каждом этапе. В соответствии с этим можно установить несколько основных этапов при оценивании любого проекта.

**Оценка потребностей рынка и аудитории.** Ее производят перед описанием бизнес-идеи. Анализ нужд рынка и целевой аудитории позволяет обосновать решение о запуске продукта. Здесь формируется понимание и видение целей и задач бизнеса, а также возможных проблем, рисков и допущений, с которыми в дальнейшем придется столкнуться. Еще этот этап позволяет определить примерные сроки реализации проекта и выделить главные показатели эффективности.

**Оценка бизнес-идеи.** Данный процесс зависит от специфики выбранного рынка и самого проекта. По этой причине универсальной методики не существует, но можно как минимум сделать этот процесс комфортным для других. К примеру, описать идею проекта простым языком, чтобы каждый участник команды понял ее суть. 

**Оценка плана управления проектом.** Ни один проект нельзя спланировать так, чтобы после старта не пришлось пересматривать стоимость его воплощения, также сроки, содержание и очередность выполнения задач. Все указанные сведения обычно уточняются в плане управления проектом, поэтому его требуется регулярно актуализировать. Проводить же эту процедуру можно по-разному – каждые 2-3 месяца в случае, если проект непродолжительный (от 3 до 9 месяцев), или же минимум ежемесячно при его высокой продолжительности.

**Оценка MVP.** Это прототип продукта с минимальным набором нужных опций, который можно продемонстрировать инвестору или потенциальным пользователям в качестве образца. Обычно это требуется для сбора обратной связи и использования этой информации в дальнейшем для доработки продукта. Для этого используются такие инструменты, как опросы клиентов, запуск тестовых посадочных страниц, оформление предзаказа и многое другое. Важный момент – не стоит считать успешное завершение теста MVP завершением всего проекта. Он должен продолжаться до тех пор, пока не будет окончательно разработан и выпущен качественный продукт.

**Оценка результата проекта.** Это уже финальная оценка, представляющая собой глубокий анализ собранных сведений и результатов работ по проекту в целом. Для этого потребуется изучить запланированные и реальные показатели, выделить лучшие инструменты, собрать обратную связь от участников команд, а также проанализировать результат для дальнейшего развития и поддержки продукта.
Если следовать указанной последовательности и проводить оценку на каждом этапе, можно минимизировать риски и ошибки в момент реализации.

 - [https://timeweb.com/ru/community/articles/etapy-ocenki-proekta-osnovnye-principy-i-poleznye-instrumenty](https://timeweb.com/ru/community/articles/etapy-ocenki-proekta-osnovnye-principy-i-poleznye-instrumenty)

## 40. Понимание различных типов тестирования (Integration, E2E, Performance).

### Интеграционное тестирование (Integration testing)

Интеграционное тестирование проверяет правильность взаимодействия узлов IT-продукта. При проведении интеграционного тестирования необходимо убедиться в том, что каждый компонент приложения работает корректно при определенном сценарии. Веб-интерфейс должен правильно отправлять запросы к API, API должен правильно обрабатывать запросы и взаимодействовать с базой данных, а база данных сохранять нужную информацию.

Кроме того, нужно убедиться в том, что приложение работает корректно в случае возникновения ошибок, например, при отсутствии соединения с базой данных. 

### Функциональное тестирование (Functional testing)

Функциональное тестирование проводится для проверки функциональности приложения. Оно позволяет убедиться в том, что приложение работает корректно и выполняет функции, соответствующие требованиям пользователей и заказчика.

Функциональное тестирование проверяет отдельные функции и возможности приложения, а интеграционное тестирование проверяет взаимодействие компонентов системы в целом.

**Пара слов о End-to-End(E2E) тестировании**, это тестирование, которое позволяет проверить работу всей системы или приложения с точки зрения пользователя от начала до конца (от "end" - начала, до "end" - конца).

Оно включает в себя проверку основных сценариев использования приложения - от взаимодействия пользователя с интерфейсом до проверки корректности ответа сервера. Также при E2E тестировании проверяются функциональные возможности приложения, такие как формирование отчетов, работа с базами данных и другие.

Таким образом, E2E тестирование можно рассматривать и как функциональное и как интеграционное.

### Регрессионное тестирование (Regression testing)

Регрессионное тестирование проводится после внесения изменений в приложение и позволяет убедиться в том, что уже существующая функциональность продукта продолжает работать корректно после изменений.

Регрессионное тестирование и функциональное тестирование имеют схожие, но все же разные цели и задачи.

Функциональное тестирование проверяет, что приложение соответствует требованиям, которые описаны в функциональных спецификациях.

Регрессионное тестирование проверяет, что изменения в приложении не повлияли на уже существующую функциональность и не вызвали регрессию (возврат к более ранней стадии разработки).

### Нагрузочное тестирование (Load testing)

Нагрузочное тестирование проводится для определения максимальной нагрузки, которую может выдержать приложение. В процессе проверяется производительность приложения и выявляются возможные проблемы в работе при большой нагрузке.

### Тестирование на производительность (Performance testing)

Тестирование на производительность проверяет производительность продукта при различных нагрузках и условиях использования. Цель - убедиться в том, что продукт может обрабатывать большое количество запросов сохраняя скорость и стабильность.

Отличие между тестированием на производительность и нагрузочным тестированием заключается в целях тестирования.

Цель тестирования на производительность - проверить, как быстро работает приложение и с какой скоростью обрабатывает определенный объем данных. Например проверяется скорость открытия страницы, время загрузки данных и т.д.

Нагрузочное тестирование, проверяет как много пользователей может использовать приложение одновременно без существенного замедления работы или падения производительности.

 - [https://habr.com/ru/companies/otus/articles/720664/](https://habr.com/ru/companies/otus/articles/720664/)

## 41. Пирамида тестирования.

«Пирамида тестов» - метафора, которая означает группировку динамических тестов программного обеспечения по разным уровням. Она также дает представление, какое количество тестов должно быть в каждой из этих групп. Основной принцип разделения уровней - тест должен быть на том же уровне, что и тестируемый объект. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты тестами более низкого уровня.

![alt text](image-6.png)

Уровни тестирования:

 - **Unit/component/program/module testing** - тестируется минимально-атомарный модуль программы, чаще всего это одна функция или метод. Таких тестов должно быть больше всего;
 - **Integration testing** - несколько модулей программы тестируются вместе;
 - **System testing** - вся программа тестируется полностью;
 - **Acceptance testing** - программа принимается заказчиком на соответствие заявленным требованиям либо тестировщики проходят end-to-end сценарии с точки зрения пользователя;

 - [https://vladislaveremeev.gitbook.io/qa_bible/vidy-metody-urovni-testirovaniya/piramida-urovni-testirovaniya-test-pyramid-testing-levels](https://vladislaveremeev.gitbook.io/qa_bible/vidy-metody-urovni-testirovaniya/piramida-urovni-testirovaniya-test-pyramid-testing-levels)

## 42. Разработка через тестирование (TDD) и разработка через поведение (BDD).

TDD (Test Driven Development) — Разработка на основе тестов.

BDD (Behavior Driven Development) — Разработка на основе поведения.

### В чем разница

TDD хорошо подходит для юнит-тестирования, т.е. для проверки работы отдельных модулей самих по себе. BDD — для интеграционного (т.е. для проверки, как отдельные модули работают друг с другом) и e2e (т.е. для проверки всей системы целиком) тестирования.

TDD: тесты сразу реализуются в коде, для BDD чаще всего описываются шаги на языке, понятном всем, а не только разработчикам.

TDD: юнит-тесты пишут сами разработчики. BDD требует объедения усилий разных членов команды. Обычно тест-кейсы (шаги) описываются ручным тестировщиком или аналитиком и воплощаются в код тестировщиком-автоматизатором. В нашей команде мы (фронтенедеры) описываем шаги вместе с тестировщиками, а код тестов пишет фронтенд-команда.

TDD проверяет работу функций, BDD — пользовательские сценарии.

### А как выглядит на примере

Давайте возьмем простую задачку. Нам нужно сделать форму, в которую мы вводим возраст котика и его вес, а в ответ получаем, сколько корма котик должен кушать в сутки.

Как подойти к этой задаче, используя TDD подход:

1. Пишем тест, в котором проверяем, что функция getCatFood() возвращает нужные значения в разных ситуациях
2. Проверяем, что тесты упали (кода еще нет)
3. Пишем код функции очень просто — так чтобы тесты прошли
4. Проверяем, что тесты прошли
5. На этом шаге можем задуматься о качестве кода. Можем спокойно рефакторить и изменять код как угодно, т.к. у нас есть тесты, которые с уверенностью скажут, что мы где-то ошиблись
6. Повторяем все вышеуказанные шаги еще раз

Как подойти к этой задаче, используя BDD подход:

1. Процесс начинается с того что пользователь открывает форму
2. Нам нужно протестировать числа которые выдает форма
3. Нам нужно ввести 10–20 разных значений
4. Проверка в данном случае это нажатие на Submit кнопку и проверка значения
5. Тест пройдет если результат на форме соответствует “правильным” значениям

Далее мы это описываем с помощью специального синтаксиса.

Из-за некоторого методологического сходства **TDD (Test Driven Development)** и **BDD (Behaviour Driven Development)** часто путают даже профессионалы. В чем же отличие? Концепции обоих подходов похожи, сначала идут тесты и только потом начинается разработка, но предназначение у них совершенно разное. 

TDD — это больше о программировании и тестировании на уровне технической реализации продукта, когда тесты создают сами разработчики. 

BDD предполагает описание тестировщиком или аналитиком пользовательских сценариев на естественном языке — если можно так выразиться, на языке бизнеса.

 - [https://medium.com/@lucyhackwrench/что-такое-tdd-и-bdd-на-пальцах-и-что-должен-знать-о-них-фронтендер-701a10e06bb9](https://medium.com/@lucyhackwrench/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-tdd-%D0%B8-bdd-%D0%BD%D0%B0-%D0%BF%D0%B0%D0%BB%D1%8C%D1%86%D0%B0%D1%85-%D0%B8-%D1%87%D1%82%D0%BE-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BE-%D0%BD%D0%B8%D1%85-%D1%84%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4%D0%B5%D1%80-701a10e06bb9)
 - [https://habr.com/ru/articles/459620/](https://habr.com/ru/articles/459620/)

## 43. Различия между HTTP и HTTPS.

### Безопасность

HTTP-сообщения представляют собой обычный текст, поэтому неавторизованные лица могут легко получить к ним доступ и прочитать их через Интернет. Напротив, HTTPS передает все данные в зашифрованном виде. Когда пользователи отправляют конфиденциальные данные, они могут быть уверены, что никакие третьи стороны не смогут их перехватить по сети. Для защиты потенциально конфиденциальной информации, например данных кредитной карты или личных данных клиентов лучше выбрать HTTPS.

### Сертификационный орган

Поисковые системы обычно оценивают содержимое веб-сайтов HTTP ниже, чем веб-страницы HTTPS, потому что HTTP менее заслуживает доверия. Клиенты также предпочитают веб-сайты HTTPS, а не HTTP. Браузер обозначает HTTPS-подключение, поместив значок замка в адресной строке браузера рядом с URL-адресом веб-сайта. Пользователи предпочитают веб-сайты и приложения HTTPS благодаря этим дополнительным факторам безопасности и доверия.

### Производительность и аналитика

Веб-приложения HTTPS загружаются быстрее, чем HTTP-приложения. Также HTTPS также лучше отслеживает реферальные ссылки. Реферальный трафик – это трафик на ваш сайт из сторонних источников, таких как реклама или обратные ссылки в социальных сетях. Вы должны включить HTTPS, если хотите, чтобы аналитическое программное обеспечение точно определяло ваши надежные источники трафика.

 - [https://aws.amazon.com/ru/compare/the-difference-between-https-and-http](https://aws.amazon.com/ru/compare/the-difference-between-https-and-http/#:~:text=HTTP%2D%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%82%20%D1%81%D0%BE%D0%B1%D0%BE%D0%B9%20%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B9,%D0%B2%D1%81%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%B2%20%D0%B7%D0%B0%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%BC%20%D0%B2%D0%B8%D0%B4%D0%B5.)

## 44. Понимание методов HTTP, заголовков, ответов и кодов состояния.

HTTP (HyperText Transfer Protocol, дословно — «протокол передачи гипертекста») представляет собой протокол прикладного уровня, используемый для доступа к ресурсам Всемирной Паутины. Под термином гипертекст следует понимать текст, в понятном для человека представлении, при этом содержащий ссылки на другие ресурсы.
В обмене информацией по HTTP-протоколу принимают участие клиент и сервер. Происходит это по следующей схеме: 

1. Клиент запрашивает у сервера некоторый ресурс.
2. Сервер обрабатывает запрос и возвращает клиенту ресурс, который был запрошен.

![alt text](image-7.png)

### Стартовая строка
Стартовая строка HTTP-запроса состоит из трех элементов:

1. Метод HTTP-запроса (method, реже используется термин verb). Обычно это короткое слово на английском, которое указывает, что конкретно нужно сделать с запрашиваемым ресурсом. Например, метод GET сообщает серверу, что пользователь хочет получить некоторые данные, а POST — что некоторые данные должны быть помещены на сервер.
2. Цель запроса. Представлена указателем ресурса URL, который состоит из протокола, доменного имени (или IP-адреса), пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров HTTP-запроса и еще ряд опциональных элементов.
3. Версия используемого протокола (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой строкой данных.

![alt text](image-8.png)

GET - Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value).О составляющих URL мы поговорим чуть позже.

POST - Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде. Обычно метод POST используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.

HEAD - Здесь придется забежать немного вперед и сказать, что обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Данный метод при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении GET-запроса к тому же ресурсу. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.

PUT - Используется для создания (размещения) новых ресурсов на сервере. Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности.

DELETE - Позволяет удалить существующие ресурсы на сервере. Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (Denial of Service, DoS) из-за удаления критически важных файлов сервера.

OPTIONS - Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.

PATCH - Позволяет внести частичные изменения в указанный ресурс по указанному расположению.

### Заголовки

HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.

В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории:

1. Общего назначения, которые применяются ко всему сообщению целиком.
2. Заголовки запроса уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.
3. Заголовки представления, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.

### Ответы HTTP

HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос. Его структура равна структуре HTTP-запроса: стартовая строка, заголовки и тело.

Строка статуса (Status line)
Стартовая строка HTTP-ответа называется строкой статуса (status line). На ней располагаются следующие элементы:

1. Уже известная нам по стартовой строке запроса версия протокола (HTTP/2 или HTTP/1.1).
2. Код состояния, который указывает, насколько успешно завершилась обработка запроса.
3. Пояснение — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.

![alt text](image-9.png)

### Коды состояния

 - 1xx - Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.
 - 2xx - Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.
 - 3xx - Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.
 - 4xx - Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа.
 - 5xx - Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.

  - [https://selectel.ru/blog/http-request/](https://selectel.ru/blog/http-request/)

## 45. Концепции RESTful API.

### Что такое REST?

REST расшифровывается как REpresentational State Transfer. Это был термин, первоначально введен Роем Филдингом (Roy Fielding), который также был одним из создателей протокола HTTP. Отличительной особенностью сервисов REST является то, что они позволяют наилучшим образом использовать протокол HTTP.

 - [https://habr.com/ru/articles/483202/](https://habr.com/ru/articles/483202/)

## 46. Базовые концепции безопасности, включая CORS, XSS и OWASP Top 10.

### CORS

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

### OWASP

Open Web Application Security Project® (OWASP) – открытый проект по обеспечению безопасности приложений, все материалы которого доступны бесплатно на веб-сайте некоммерческой организации OWASP® Foundation. Поставляемые материалы включают документацию, мероприятия, форумы, проекты, инструменты и видео, такие как OWASP Top 10, веб-протоколы OWASP CLASP и OWASP ZAP, а также сканер веб-приложений с открытым исходным кодом.

Что такое топ-10 уязвимостей OWASP и как он работает?
OWASP Top 10 – это отчет или информационный документ, в котором перечислены основные проблемы, связанные с безопасностью веб-приложений. Он регулярно обновляется, чтобы постоянно отображать 10 наиболее серьезных рисков, с которыми сталкиваются организации. OWASP рекомендует всем компаниям учитывать выводы документа при построении корпоративных процессов, чтобы минимизировать и смягчить актуальные риски безопасности.

OWASP определяет Top Ten угроз:

- (A1) Injection;
- (A2) Broken Authentication;
- (A3) Sensitive Data Exposure;
- (A4) XML External Entities (XXE);
- (A5) Broken Access Control;
- (A6) Security Misconfiguration;
- (A7) Cross-Site Scripting (XSS);
- (A8) Insecure Deserialization;
- (A9) Using Components w/ Known Vulnerabilities;
- (A10) Insufficient Logging & Monitoring.

### XSS (когда злоумышленник пытается выполнить свой JavaScript в нашем приложении).

- Экранирование входных данных.
- Content Security Policy (CSP).
- X-XSS-Protection.
- Сookies: HTTP-only, Secure, SameSite.
- Библиотеки / фреймворки (например, Microsoft AntiXSS).

 - [https://habr.com/ru/companies/oleg-bunin/articles/564630/](https://habr.com/ru/companies/oleg-bunin/articles/564630/)
 - [https://developer.mozilla.org/ru/docs/Web/HTTP/CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)
 - [https://proglib.io/p/chto-takoe-top-10-owasp-i-kakie-uyazvimosti-veb-prilozheniy-naibolee-opasny-2021-09-09](https://proglib.io/p/chto-takoe-top-10-owasp-i-kakie-uyazvimosti-veb-prilozheniy-naibolee-opasny-2021-09-09)

## 47. Механизмы аутентификации (JWT, OAuth).

### Структура JWT

JWT состоит из трех частей: заголовок header, полезные данные payload и подпись signature.

**Шаг 1. Создаем HEADER**

Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись. Хедер — это тоже JSON объект, который выглядит следующим образом:

```javascript
header = { "alg": "HS256", "typ": "JWT"}
```

Поле typ не говорит нам ничего нового, только то, что это JSON Web Token. Интереснее здесь будет поле alg, которое определяет алгоритм хеширования. Он будет использоваться при создании подписи. HS256 — не что иное, как HMAC-SHA256, для его вычисления нужен лишь один секретный ключ (более подробно об этом в шаге 3). Еще может использоваться другой алгоритм RS256 — в отличие от предыдущего, он является ассиметричным и создает два ключа: публичный и приватный. С помощью приватного ключа создается подпись, а с помощью публичного только лишь проверяется подлинность подписи, поэтому нам не нужно беспокоиться о его безопасности.

**Шаг 2. Создаем PAYLOAD**

Payload — это полезные данные, которые хранятся внутри JWT. Эти данные также называют JWT-claims (заявки). В примере, который рассматриваем мы, сервер аутентификации создает JWT с информацией об id пользователя — userId.

```javascript
payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
```

Мы положили только одну заявку (claim) в payload. Вы можете положить столько заявок, сколько захотите. Существует список стандартных заявок для JWT payload — вот некоторые из них:


 - iss (issuer) — определяет приложение, из которого отправляется токен.
 - sub (subject) — определяет тему токена.
 - exp (expiration time) — время жизни токена.

Эти поля могут быть полезными при создании JWT, но они не являются обязательными. Если хотите знать весь список доступных полей для JWT, можете заглянуть в Wiki. Но стоит помнить, что чем больше передается информации, тем больший получится в итоге сам JWT. Обычно с этим не бывает проблем, но все-таки это может негативно сказаться на производительности и вызвать задержки во взаимодействии с сервером.

**Шаг 3. Создаем SIGNATURE**

Подпись вычисляется с использование следующего псевдо-кода:

```javascript
const SECRET_KEY = 'cAtwa1kkEy'
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)
const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
```

Алгоритм base64url кодирует хедер и payload, созданные на 1 и 2 шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.

```javascript
// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

**Шаг 4. Теперь объединим все три JWT компонента вместе**

Теперь, когда у нас есть все три составляющих, мы можем создать наш JWT. Это довольно просто, мы соединяем все полученные элементы в строку через точку.

```javascript
const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature)
// JWT Token
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

Вы можете попробовать создать свой собственный JWT на сайте jwt.io.
Вернемся к нашему примеру. Теперь сервер аутентификации может слать пользователю JWT.

**Шаг 5. Проверка JWT**

В нашем простом примере из 3 участников мы используем JWT, который подписан с помощью HS256 алгоритма и только сервер аутентификации и сервер приложения знают секретный ключ. Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к JWT, что в шаге 3. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит JWT валидный, т.е. пришел от проверенного источника. Если подписи не совпадают, значит что-то пошло не так — возможно, это является признаком потенциальной атаки. Таким образом, проверяя JWT, приложение добавляет доверительный слой (a layer of trust) между собой и пользователем.

### OAuth 2

OAuth 2 — это платформа авторизации, которая позволяет приложениям, таким как Facebook, GitHub и DigitalOcean, получать ограниченный доступ к учетным записям пользователей в службе HTTP. Он работает путем делегирования аутентификации пользователя службе, на которой размещена учетная запись пользователя, и разрешения сторонним приложениям доступа к этой учетной записи пользователя. OAuth 2 обеспечивает потоки авторизации для веб-приложений и настольных приложений, а также мобильных устройств.

**Роли OAuth**

OAuth определяет четыре роли:

- Владелец ресурса : Владелец ресурса — это пользователь , который разрешает приложению доступ к своей учетной записи. Доступ приложения к учетной записи пользователя ограничен объемом предоставленных полномочий (например, доступ на чтение или запись).
- Клиент : Клиент — это приложение , которое хочет получить доступ к учетной записи пользователя . Прежде чем он сможет это сделать, он должен быть авторизован пользователем, а авторизация должна быть подтверждена API.
- Сервер ресурсов : на сервере ресурсов размещаются защищенные учетные записи пользователей.
- Сервер авторизации : Сервер авторизации проверяет личность пользователя, а затем выдает токены доступа приложению.

**Регистрация приложения**

Прежде чем использовать OAuth в своем приложении, вы должны зарегистрировать свое приложение в службе. Это делается через регистрационную форму в разделе разработчика или API веб-сайта службы, где вы предоставляете следующую информацию (и, возможно, подробную информацию о вашем приложении):

- Имя приложения
- Веб-сайт приложения
- URI перенаправления или URL обратного вызова
- URI перенаправления — это место, куда служба будет перенаправлять пользователя после того, как он авторизует (или отклоняет) ваше приложение, и, следовательно, ту часть вашего приложения, которая будет обрабатывать коды авторизации или токены доступа.

**Идентификатор клиента и секрет клиента**

После регистрации вашего приложения служба выдаст учетные данные клиента в виде идентификатора клиента и секретного кода клиента . Идентификатор клиента — это общедоступная строка, которая используется API службы для идентификации приложения, а также для создания URL-адресов авторизации, которые предоставляются пользователям. Секрет клиента используется для проверки подлинности приложения в API службы, когда приложение запрашивает доступ к учетной записи пользователя, и должен оставаться конфиденциальным между приложением и API.

 - [https://habr.com/ru/articles/340146/](https://habr.com/ru/articles/340146/)
 - [https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)