# CoreJS Interview #2

## Кратко и тезисно темы интервью для самопроверки и повторения ранее изученного материала

### Темы по JavaScript:

#### **Модули в JavaScript**

- [Назначение и концепция шаблона Module.](#1-назначение-и-концепция-шаблона-module)
- [Типы модулей (AMD, ES6, CommonJS, UMD).](#2-типы-модулей-amd-es6-commonjs-umd)
- [Синтаксис и общие функции (export default, named exports, exports as).](#3-синтаксис-и-общие-функции-export-default-named-exports-exports-as)
- [Динамический импорт.](#4-динамический-импорт)

#### **Функциональные шаблоны**

- [Колбэки и IIFE.](#5-колбэки-и-iife)
- [Ограничения колбэков (например, callback hell).](#6-ограничения-колбэков-например-callback-hell)
- [Каррирование функций и частичные функции.](#7-каррирование-функций-и-частичные-функции)

#### **Объектно-ориентированное программирование (ООП)**

- [Функциональность ключевого слова `new`.](#8-функциональность-ключевого-слова-new)
- [Функции-конструкторы и их свойства.](#9-функции-конструкторы-и-их-свойства)
- [Публичные, частные и статические члены в ООП.](#10-публичные-частные-и-статические-члены-в-ооп)

#### **Классы ECMAScript**

- [Объявление класса и синтаксис.](#11-объявление-класса-и-синтаксис)
- [Различия между объявлениями классов и функциями-конструкторами.](#12-различия-между-объявлениями-классов-и-функциями-конструкторами)
- [Использование `super()`.](#13-использование-super)

#### **Прототипическое наследование**

- [Свойства, такие как `__proto__` и `prototype`.](#14-свойства-такие-как-__proto__-и-prototype)
- [Использование [Object.create] для явного определения прототипов.](#15-использование-objectcreate-для-явного-определения-прототипов)

#### **Расширенные типы данных и выражения ECMAScript**

- [`Set/Map` и `WeakSet/WeakMap`.](#16-setmap-и-weaksetweakmap)

#### **Ошибки JavaScript**

- [Методы обработки ошибок, включая `try..catch`.](#17-методы-обработки-ошибок-включая-trycatch)
- [Понимание и реализация пользовательских ошибок.](#18-понимание-и-реализация-пользовательских-ошибок)

#### **ECMAScript Расширенный**

- [Promises, async/await и Event loop.](#19-promises-asyncawait-и-event-loop)
- [Основы сбора мусора.](#20-основы-сбора-мусора)

### JavaScript в браузере:

#### **Глобальный объект window**

- [Понимание location браузера и history API.](#21-понимание-location-браузера-и-history-api)
- [Анализ user-agent и определение платформы/браузера (объект navigator).](#22-анализ-user-agent-и-определение-платформыбраузера-объект-navigator)

#### **Жизненный цикл страницы**

- [Анализ, перекомпоновка, перерисовка и критический путь рендеринга.](#23-анализ-перекомпоновка-перерисовка-и-критический-путь-рендеринга)

#### **Сетевые запросы**

- [Использование «Fetch» ​​и понимание «XMLHTTPRequest».](#24-использование-fetch-и-понимание-xmlhttprequest)

#### **Таймеры**

- [Различия между setTimeout и requestAnimationFrame.](#25-различия-между-settimeout-и-requestanimationframe)

### TypeScript:

* Написание эффективного TypeScript с использованием базовых типов, перечислений, интерфейсов и дженериков:
  - [основные типы](#26-основные-типы)
  - [перечисления](#27-перечисления)
  - [тип/интерфейс, различия между ними](#28-типинтерфейс-различия-между-ними)
  - [использование интерфейсов с необязательными свойствами, свойствами только для чтения и т. д.](#29-использование-интерфейсов-с-необязательными-свойствами-свойствами-только-для-чтения-и-т-д)
  - [типы функций](#30-типы-функций)
  - [utility types `(необязательно)`](#31-utility-types-необязательно)
  - [typeguards `(необязательно)`](#32-typeguards-необязательно)
  - [создание пользовательских типов](#33-создание-пользовательских-типов)
  - [дженерики `(концепция)`](#34-дженерики-концепция)
* [Понимание системы модулей в ES6 и TypeScript.](#35-понимание-системы-модулей-в-es6-и-typescript)

### Паттерны проектирования:

- Знакомство с паттернами порождающие, структурные и поведенческие.
- Принципы SOLID и паттерны проектирования в контексте проекта.

### Методологии разработки программного обеспечения:

- Методологии Agile, Scrum, Kanban и Waterfall.
- Методы оценки проекта.

### Тестирование:

- Понимание различных типов тестирования (Integration, E2E, Performance).
- Пирамида тестирования.
- Разработка через тестирование (TDD) и разработка через поведение (BDD).

### Протоколы веб-коммуникаций:

- Различия между HTTP и HTTPS.
- Понимание методов HTTP, заголовков, ответов и кодов состояния.
- Концепции RESTful API.

### Общие знания в области веб-безопасности:

- Базовые концепции безопасности, включая CORS, XSS и OWASP Top 10.
- Механизмы аутентификации (JWT, OAuth).

---

## 1. Назначение и концепция шаблона Module.

«Модуль» — это популярная реализация паттерна, инкапсулирующего приватную информацию, состояние и структуру, используя замыкания. Это позволяет оборачивать публичные и приватные методы и переменные в модули, и предотвращать их попадание в глобальный контекст, где они могут конфликтовать с интерфейсами других разработчиков. Паттерн «модуль» возвращает только публичную часть API, оставляя всё остальное доступным только внутри замыканий.

Это хорошее решение для того, чтобы скрыть внутреннюю логику от посторонних глаз и производить всю тяжелую работу исключительно через интерфейс, который вы определите для использования в других частях вашего приложения. Этот паттерн очень похож на немедленно-вызываемые функции (IIFE), за тем исключением, что модуль вместо функции, возвращает объект.

## 2. Типы модулей (AMD, ES6, CommonJS, UMD).

Модуль — это переиспользуемая часть кода, содержащая в себе детали реализации и предоставляющая открытое API, что позволяет легко загрузить её и использовать в другом коде.

Вот несколько наиболее известных и широко используемых:

 - асинхронное определение модуля (Asynchronous Module Definition или AMD);
 - CommonJS;
 - универсальное определение модуля (Universal Module Definition или UMD);
 - System.register;
 - формат модуля ES6.

#### Асинхронное определение модуля (AMD)

Формат AMD используется в браузерах и применяет для определения модулей функцию define:

```
//Вызов функции define с массивом зависимостей и фабричной функцией
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Определение модуля с помощью возвращаемого значения
    return function () {};
});
```

#### Формат CommonJS

Формат CommonJS применяется в Node.js и использует для определения зависимостей и модулей require и module.exports:

```
var dep1 = require('./dep1');  
var dep2 = require('./dep2');

module.exports = function(){  
 // ...
}
```

#### Универсальное определение модуля (UMD)

Формат UMD может быть использован как в браузере, так и в Node.js.

```
(function (root, factory) {
 if (typeof define === 'function' && define.amd) {
   // AMD. Подключение анонимного модуля
     define(['b'], factory);
 } else if (typeof module === 'object' && module.exports) {
   // Node. Не работает с CommonJS напрямую, 
   // только CommonJS-образными средами, которые поддерживают      

   // module.exports, как Node.
   module.exports = factory(require('b'));
 } else {
   // Глобальные переменные браузера (root это window)
   root.returnExports = factory(root.b);
 }
}(this, function (b) {
 //как-нибудь использовать b.

 // Просто возвращаем значение для определения модуля.
 // Этот пример возвращает объект, но модуль 
 // может вернуть и функцию как экспортируемое значение.
 return {};
}));
```

#### System.registerА

Формат System.register был разработан для поддержки синтаксиса модулей ES6 в ES5:

```
import { p as q } from './dep';

var s = 'local';

export function func() {  
 return q;
}

export class C {  
}
```

#### Формат модулей ES6

В ES6 JavaScript уже поддерживает нативный формат модулей.
Он использует токен export для экспорта публичного API модуля:

```
// lib.js

// Экспорт функции
export function sayHello(){  
 console.log('Hello');
}

// Не экспоруемая функция
function somePrivateFunction(){  
 // ...
}
```

## 3. Синтаксис и общие функции (export default, named exports, exports as).

Модуль – это просто файл. Один скрипт – это один модуль.
Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:

 - export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
 - import позволяет импортировать функциональность из других модулей.

Модули не работают локально. Только через HTTP(s).
Если вы попытаетесь открыть веб-страницу локально, через протокол file://, вы обнаружите, что директивы import/export не работают. Для тестирования модулей используйте локальный веб-сервер, например, static-server или используйте возможности «живого сервера» вашего редактора, например, расширение Live Server для VS Code.

#### Основные возможности модулей:

 - Всегда «use strict»
В модулях всегда используется режим use strict. Например, присваивание к необъявленной переменной вызовет ошибку.
 - Своя область видимости переменных
Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
 - Код в модуле выполняется только один раз при импорте
Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
 - import.meta
Объект import.meta содержит информацию о текущем модуле. Содержимое зависит от окружения. В браузере он содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML.
 - В модуле «this» не определён
В модуле на верхнем уровне this не определён (undefined).
 - Модули являются отложенными (deferred)
Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer. Это верно и для внешних и встроенных скриптов-модулей.
 - Атрибут async работает во встроенных скриптах
Для не-модульных скриптов атрибут async работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ. Для модулей атрибут async работает на любых скриптах.
 - Внешние скрипты
Внешние скрипты с атрибутом type="module" имеют два отличия:
   * Внешние скрипты с одинаковым атрибутом src запускаются только один раз:
   * Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена.Это обеспечивает лучшую безопасность по умолчанию.
 - Не допускаются «голые» модули
В браузере import должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» (bare). Они не разрешены в import. Другие окружения, например Node.js, допускают использование «голых» модулей, без путей, так как в них есть свои правила, как работать с такими модулями и где их искать.
 - Совместимость, «nomodule»
Старые браузеры не понимают атрибут type="module". Скрипты с неизвестным атрибутом type просто игнорируются. Мы можем сделать для них «резервный» скрипт при помощи атрибута nomodule.

#### Синтаксис export:

Перед объявлением класса/функции/…:
`export [default] class/function/variable ...`
Отдельный экспорт:
`export {x [as y], ...}.`
Реэкспорт:
`export {x [as y], ...} from "module"`
`export * from "module"` (не реэкспортирует `export default`).
`export {default [as y]} from "module"` (реэкспортирует только `export default`).

#### Синтаксис import:

Именованные экспорты из модуля:
`import {x [as y], ...} from "module"`
Импорт по умолчанию:
`import x from "module"`
`import {default as x} from "module"`
Всё сразу:
`import * as obj from "module"`
Только подключить модуль (его код запустится), но не присваивать его переменной:
`import "module"`
Мы можем поставить import/export в начало или в конец скрипта, это не имеет значения.
То есть, технически, такая запись вполне корректна:

```
sayHi();

// ...

import {sayHi} from './say.js'; // импорт в конце файла
```

На практике импорты, чаще всего, располагаются в начале файла. Но это только для большего удобства.

## 4. Динамический импорт.

Выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.
Использовать его мы можем динамически в любом месте кода, например, так:

```
let modulePath = prompt("Какой модуль загружать?");

import(modulePath)
  .then(obj => <объект модуля>)
  .catch(err => <ошибка загрузки, например если нет такого модуля>)
```

Или если внутри асинхронной функции, то можно `let module = await import(modulePath)`.

Например, если у нас есть такой модуль say.js:

```
// say.js
export function hi() {
  alert(`Привет`);
}

export function bye() {
  alert(`Пока`);
}
```

Динамический импорт работает в обычных скриптах, он не требует указания `script type="module"`.
Хотя `import()` и выглядит похоже на вызов функции, на самом деле это специальный синтаксис, так же, как, например, `super()`.
Так что мы не можем скопировать import в другую переменную или вызвать при помощи .call/apply. Это не функция.

## 5. Колбэки и IIFE.

#### Колбэк-функция

Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.
Вот краткий пример:

```
function greeting(name) {
  alert("Hello " + name);
}

function processUserInput(callback) {
  var name = prompt("Please enter your name.");
  callback(name);
}

processUserInput(greeting);
```

Выше приведён пример синхронного колбэка, поскольку функция processUserInput выполняется синхронно.
Колбэки часто используются для продолжения выполнения кода после завершения асинхронной операции - они называются асинхронными колбэками.

#### IIFE

IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.

```
(function () {
    statements
})();
```

Это тип выражений, также известный как Self-Executing Anonymous Function, который состоит из двух основных частей. 
 - Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки (). Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.
 - Вторая часть создаёт мгновенно выполняющееся функциональное выражение () , благодаря которому JavaScript-движок выполняет функцию напрямую.

Функция становится мгновенно выполняющимся функциональным выражением. Переменные внутри функции не могут быть использованы за пределами её области видимости.

```
(function () {
    var aName = "Barry";
})();
// Variable name is not accessible from the outside scope
aName // throws "Uncaught ReferenceError: aName is not defined"
```

Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.

```
var result = (function () {
    var name = "Barry";
    return name;
})();
// Immediately creates the output:
result; // "Barry"
```

## 6. Ограничения колбэков (например, callback hell).

#### Что такое «ад обратных вызовов»?

Асинхронный JavaScript или JavaScript, в котором используются обратные вызовы — это то, в чём трудно интуитивно разобраться. В основном код заканчивается вот так:

```
fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err);
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename);
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err);
        } else {
          console.log(filename + ' : ' + values);
          var aspect = (values.width / values.height);
          widths.forEach(function (width, widthIndex) {
            var height = Math.round(width / aspect);
            console.log('resizing ' + filename + 'to ' + height + 'x' + height);
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function (err) {
              if (err) {
                console.log('Error writing file: ' + err);
              }
            });
          }.bind(this));
        }
      });
    });
  }
});
```

Видите форму пирамиды и все эти `})` в конце? Фу! Это ласково называют адом обратных вызовов (callback hell).

#### Как выбраться из ада обратных вызовов?

1. Избегайте большой вложенности функций. Дайте им имена и разместите их на верхнем уровне программы.
2. Используйте поднятие функций чтобы переместить объявление функций в нижнюю часть страницы.
3. Обрабатывайте каждую ошибку в каждом обратном вызове. Для этого подойдёт линтер standard.
4. Создавайте переиспользуемые функции и помещайте их в модули, чтобы сократить время для понимания вашего кода. Разделяйте код на маленькие кусочки — это поможет обрабатывать ошибки, писать тесты, заставит вас создавать стабильный, задокументированный публичный API и облегчит его рефакторинг.

## 7. Каррирование функций и частичные функции.

#### Каррирование

Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
Каррирование не вызывает функцию. Оно просто трансформирует её.

Давайте сначала посмотрим на пример, чтобы лучше понять, о чём речь, а потом на практическое применение каррирования.

Создадим вспомогательную функцию curry(f), которая выполняет каррирование функции f с двумя аргументами. Другими словами, curry(f) для функции f(a, b) трансформирует её в f(a)(b).

```
function curry(f) { // curry(f) выполняет каррирование
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// использование
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
```

Как вы видите, реализация довольна проста: это две обёртки.
Результат curry(func) – обёртка function(a).
Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.

#### Каррирование? Зачем?

Чтобы понять пользу от каррирования, нам определённо нужен пример из реальной жизни.

Например, у нас есть функция логирования log(date, importance, message), которая форматирует и выводит информацию. В реальных проектах у таких функций есть много полезных возможностей, например, посылать логи по сети, здесь для простоты используем alert:

```
function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}
```

А теперь давайте применим к ней каррирование!

```
log = _.curry(log);
```

После этого log продолжает работать нормально:

```
log(new Date(), "DEBUG", "some debug"); // log(a, b, c)
```

…Но также работает вариант с каррированием:

```
log(new Date())("DEBUG")("some debug"); // log(a)(b)(c)
```

Давайте сделаем удобную функцию для логов с текущим временем:

```
// logNow будет частичным применением функции log с фиксированным первым аргументом
let logNow = log(new Date());

// используем её
logNow("INFO", "message"); // [HH:mm] INFO message
```

Теперь logNow – это log с фиксированным первым аргументом, иначе говоря, «частично применённая» или «частичная» функция.
Мы можем пойти дальше и сделать удобную функцию для именно отладочных логов с текущим временем:

```
let debugNow = logNow("DEBUG");

debugNow("message"); // [HH:mm] DEBUG message
```

Итак:
1. Мы ничего не потеряли после каррирования: log всё так же можно вызывать нормально.
2. Мы можем легко создавать частично применённые функции, как сделали для логов с текущим временем.

Для каррирования необходима функция с фиксированным количеством аргументов.
Функцию, которая использует остаточные параметры, типа f(...args), так каррировать не получится.

## 8. Функциональность ключевого слова `new`.

Ключевое слово `new` в JavaScript используется для создания экземпляра объекта, который содержит функцию конструктора. При вызове функции-конструктора с оператором new выполняются следующие действия:

1. Создается новый пустой объект;
2. Внутреннее свойство prototype нового объекта (__proto__) становится таким же, как и у конструирующей функции;
3. Переменная this указывает на вновь созданный объект. Свойство, объявленное с ключевым словом this, привязано к новому объекту;
4. Созданный объект возвращается, когда функция-конструктор возвращает не примитивное значение (т.е. объект JavaScript). Если функция-конструктор возвращает примитивное значение, оно будет проигнорировано. Если в конце функции ничего не возвращается, то функция возвращает this.

Синтаксис:

```
new СonstructorFunction(arguments)
```

Параметры:

 - `ConstructorFunction`: класс или функция, определяющая тип экземпляра объекта.
 - `Arguments`: список значений, с которыми будет вызываться конструктор.

Рассмотрим пример:

```
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
```

Когда функция вызывается как new User(...), происходит следующее:

 - Создаётся новый пустой объект, и он присваивается this.
 - Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
 - Возвращается значение this.

Другими словами, new User(...) делает что-то вроде:

```
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
```

## 9. Функции-конструкторы и их свойства.

Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:

1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна выполняться только с помощью оператора "new".

#### Проверка на вызов в режиме конструктора: new.target

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
В случае обычного вызова функции new.target будет undefined. Если же она была вызвана при помощи new, new.target будет равен самой функции.

```
function User() {
  alert(new.target);
}

// без "new":
User(); // undefined

// с "new":
new User(); // function User { ... }
```

Это можно использовать внутри функции, чтобы узнать, была ли она вызвана при помощи `new`, «в режиме конструктора», или без него, «в обычном режиме».
Также мы можем сделать, чтобы вызовы с new и без него делали одно и то же:

```
function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }

  this.name = name;
}

let john = User("John"); // переадресовывает вызов на new User
alert(john.name); // John
```

Такой подход иногда используется в библиотеках, чтобы сделать синтаксис более гибким. Чтобы люди могли вызывать функцию с new и без него, и она все ещё могла работать.

#### Возврат значения из конструктора, return

Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.
Но если return всё же есть, то применяется простое правило:

 - При вызове return с объектом, вместо this вернётся объект.
 - При вызове return с примитивным значением, оно проигнорируется.

#### Пропуск скобок

Мы можем не ставить круглые скобки после new:

```
let user = new User; // <-- без скобок
// то же, что и
let user = new User();
```

Пропуск скобок считается плохой практикой, но такой синтаксис разрешён спецификацией.

#### Создание методов в конструкторе

Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.

Конечно, мы можем добавить к this не только свойства, но и методы.
Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:

```
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

## 10. Публичные, частные и статические члены в ООП.

#### Внутренний и внешний интерфейсы

В объектно-ориентированном программировании свойства и методы разделены на 2 группы:

 - Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
 - Внешний интерфейс – методы и свойства, доступные снаружи класса.

В JavaScript есть два типа полей (свойств и методов) объекта:

 - Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
 - Приватные: доступны только внутри класса. Они для внутреннего интерфейса.

Во многих других языках также существуют «защищённые» поля, доступные только внутри класса или для дочерних классов (то есть, как приватные, но разрешён доступ для наследующих классов) и также полезны для внутреннего интерфейса. В некотором смысле они более распространены, чем приватные, потому что мы обычно хотим, чтобы наследующие классы получали доступ к внутренним полям.

Защищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют.

Защищённые свойства обычно начинаются с префикса _.

Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.

Приватные свойства и методы должны начинаться с #. 

Они доступны только внутри класса.
На уровне языка # является специальным символом, который означает, что поле приватное. Мы не можем получить к нему доступ извне или из наследуемых классов.
Приватные поля не конфликтуют с публичными.

#### Статические свойства и методы

Мы также можем присвоить метод самому классу. Такие методы называются статическими.
В объявление класса они добавляются с помощью ключевого слова static, например:

```
class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // true
```

Это фактически то же самое, что присвоить метод напрямую как свойство функции:

```
class User { }

User.staticMethod = function() {
  alert(this === User);
};
```

Значением this при вызове User.staticMethod() является сам конструктор класса User (правило «объект до точки»).

#### Статические свойства

Статические свойства также возможны, они выглядят как свойства класса, но с static в начале:

```
class Article {
  static publisher = "Илья Кантор";
}

alert( Article.publisher ); // Илья Кантор
```

Это то же самое, что и прямое присваивание Article:

```
Article.publisher = "Илья Кантор";
```

Статические свойства и методы наследуются.


## 11. Объявление класса и синтаксис.

Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный способ создания объектов и организации наследования.

Синтаксис «class»
Базовый синтаксис выглядит так:

```
class MyClass {
  // методы класса
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```

Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.
При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.

На самом деле классы — это "специальные функции", поэтому точно также, как вы определяете функции (function expressions и function declarations), вы можете определять и классы с помощью: class declarations и class expressions.

**Первый способ определения класса** — class declaration (объявление класса). Для этого необходимо воспользоваться ключевым словом class и указать имя класса (в примере — «Rectangle»).

```
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

**Второй способ определения класса** — class expression (выражение класса). Можно создавать именованные и безымянные выражения. В первом случае имя выражения класса находится в локальной области видимости класса и может быть получено через свойства самого класса, а не его экземпляра.

```
// безымянный
var Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// отобразится: "Rectangle"

// именованный
var Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// отобразится: "Rectangle2"
```

Ключевое слово extends используется в объявлениях классов и выражениях классов для создания класса, дочернего относительно другого класса.

```
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} издаёт звук.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // вызывает конструктор super класса и передаёт параметр name
  }

  speak() {
    console.log(`${this.name} лает.`);
  }
}

let d = new Dog("Митци");
d.speak(); // Митци лает
```

Если в подклассе присутствует конструктор, он должен сначала вызвать super, прежде чем использовать this.

## 12. Различия между объявлениями классов и функциями-конструкторами.

Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление функции совершает подъём (hoisted), в то время как объявление класса — нет. Поэтому вначале необходимо объявить ваш класс и только затем работать с ним.

## 13. Использование `super()`.

Ключевое слово super используется для вызова функций, принадлежащих родителю объекта.

В конструкторе ключевое слово super() используется как функция, вызывающая родительский конструктор. Её необходимо вызвать до первого обращения к ключевому слову this в теле конструктора. Ключевое слово super также может быть использовано для вызова функций родительского объекта.

Вы не можете использовать оператор delete и super.prop или super[expr] для удаления свойств родительского класса, он выдаст: ReferenceError.

При определении незаписываемых свойств с помощью, например, Object.defineProperty, super не может перезаписать значение свойства.


## 14. Свойства, такие как `__proto__` и `prototype`.

#### Свойство __proto__

Абсолютно любой объект в JavaScript имеет свойство __proto__. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю.
При обращении к любому свойству объекта, оно в первую очередь ищется в самом объекте:

```
var obj = {ownProperty: 1};

console.log(obj.ownProperty);// 1
```

Но если его там нет, поиск происходит в свойстве __proto__:

```
obj.__proto__ = {propertyOfProto: 2};
console.log(obj.propertyOfProto);// 2
```

Если его нет и там, оно ищется дальше по цепочке:

```
obj.__proto__.__proto__ = {propertyOfProtosProto: 3};
console.log(obj.propertyOfProtosProto);// 3
```

Эта цепочка называется цепочкой прототипов (prototype chain).

__proto__ любого значения (кроме null и undefined) ссылается на prototype соответствующего ему типу данных:

```
(0).__proto__ === Number.prototype &&
false.__proto__ === Boolean.prototype &&
"string".__proto__ === String.prototype &&
(new Date).__proto__ === Date.prototype &&
(function(){}/* new Function */).__proto__ === Function.prototype
```

Все типы данных наследуются от Object, это означает что к примеру:

```
Number.prototype.__proto__ === Object.prototype
```

И наконец, завершение цепочки:

```
Object.prototype.__proto__ === null
```

#### Свойство prototype

А чем же тогда является свойство prototype? Это обычное свойство, ничем не отличающиеся от любых других свойств. За исключением двух особенностей:

1. Функции в JavaScript имеют свойство prototype. Оно по умолчанию является объектом с единственным свойством constructor, которое ссылается на саму функцию.
2. Свойство prototype используется при создании новых объектов оператором new.

#### Оператор new

Этот оператор делает следущее:

1. Создает пустой объект:
var instance = {};

2. Устанавливает __proto__ этому объекту ссылкой на prototype функции-конструктора:
instance.__proto__ = FnClass.prototype;

3. Применяет функцию-конструктор к нашему новосозданному объекту:
constructorReturns = FnClass.apply(instance, arguments);
(т.е. исполняет функцию FnClass, передавая ей instance в качестве this и аргументы в виде массива arguments)

4. Возвращает экземпляр функции-класса, но если FnClass нам вернул обьект, тогда его:
return constructorReturns instanceof Object ? constructorReturns : instance;

## 15. Использование [Object.create] для явного определения прототипов.

`Object.create(proto[, descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
У Object.create есть необязательный второй аргумент: дескрипторы свойств.
Дескриптор свойства — это запись с некоторыми из следующих атрибутов:

 - value - Значение, ассоциированное со свойством (только в дескрипторе данных).
 - writable - Значение true, если значение, ассоциированное со свойством, может быть изменено, иначе false (только в дескрипторе данных).
 - get - Функция, возвращающая значение свойства, либо undefined, если такая функция отсутствует (только в дескрипторе доступа).
 - set - Функция, изменяющая значение свойства, либо undefined, если такая функция отсутствует (только в дескрипторе доступа).
 - configurable - Значение true, если тип дескриптора этого свойства может быть изменён и если свойство может быть удалено из содержащего его объекта, иначе false.
 - enumerable - Значение true, если это свойство доступно при перечислении свойств содержащего его объекта, иначе false.

## 16. `Set/Map` и `WeakSet/WeakMap`.

#### Map

Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Методы и свойства:

 - `new Map()` – создаёт коллекцию.
 - `map.set(key, value)` – записывает по ключу key значение value.
 - `map.get(key)` – возвращает значение по ключу или undefined, если ключ key отсутствует.
 - `map.has(key)` – возвращает true, если ключ key присутствует в коллекции, иначе false.
 - `map.delete(key)` – удаляет элемент (пару «ключ/значение») по ключу key.
 - `map.clear()` – очищает коллекцию от всех элементов.
 - `map.size` – возвращает текущее количество элементов.

**Перебор Map**

Для перебора коллекции Map есть 3 метода:

 - `map.keys()` – возвращает итерируемый объект по ключам,
 - `map.values()` – возвращает итерируемый объект по значениям,
 - `map.entries()` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

#### Set

Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

 - `new Set(iterable)` – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
 - `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
 - `set.delete(value)` – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
 - `set.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.
 - `set.clear()` – удаляет все имеющиеся значения.
 - `set.size` – возвращает количество элементов в множестве.
Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

**Перебор объекта Set**

Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach.

Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

Set имеет те же встроенные методы, что и Map:

 - `set.values()` – возвращает перебираемый объект для значений,
 - `set.keys()` – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
 - `set.entries()` – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

#### WeakMap и WeakSet

WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map.

То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти.

Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект.

Таким образом, WeakMap избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект.

У WeakMap есть ряд ограничений:

 - Только объекты в качестве ключей.
 - Нет свойства size.
 - Нельзя перебрать элементы итератором или forEach.
 - Нет метода clear().

Иными словами, WeakMap работает только на запись (set, delete) и чтение (get, has) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое WeakMap, нет соответствующих методов.
Это связано с тем, что содержимое WeakMap может быть модифицировано сборщиком мусора в любой момент, независимо от программиста.

То же самое относится и к WeakSet: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.
Эти ограничения могут показаться неудобными, но, по сути, они не мешают WeakMap/WeakSet выполнять свою основную задачу – быть «вторичным» хранилищем данных для объектов, актуальный список которых (и сами они) хранится в каком-то другом месте.

## 17. Методы обработки ошибок, включая `try..catch`.

Синтаксис «try…catch».

Конструкция try..catch состоит из двух основных блоков: try, и затем catch:

```
try {

  // код...

} catch (err) {

  // обработка ошибки

}
```

Работает она так:

Сначала выполняется код внутри блока try {...}.

Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.

Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

Таким образом, при ошибке в блоке try {…} скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch.

try..catch работает синхронно.
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает.

Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch.

Для всех встроенных ошибок этот объект имеет два основных свойства:

 - `name` - Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
 - `message` - Текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:

 - `stack` - Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.

Если нам не нужны детали ошибки, в catch можно её пропустить.

Конструкция try..catch может содержать ещё одну секцию: finally.

Если секция есть, то она выполняется в любом случае:

 - после try, если не было ошибок,
 - после catch, если ошибки были.

Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

## 18. Понимание и реализация пользовательских ошибок.

Когда что-то разрабатываем, то нам часто необходимы собственные классы ошибок для разных вещей, которые могут пойти не так в наших задачах. Для ошибок при работе с сетью может понадобиться HttpError, для операций с базой данных DbError, для поиска – NotFoundError и т.д.

Наши ошибки должны поддерживать базовые свойства, такие как message, name и, желательно, stack. Но также они могут иметь свои собственные свойства. Например, объекты HttpError могут иметь свойство statusCode со значениями 404, 403 или 500.

JavaScript позволяет вызывать throw с любыми аргументами, то есть технически наши классы ошибок не нуждаются в наследовании от Error. Но если использовать наследование, то появляется возможность идентификации объектов ошибок посредством obj instanceof Error. Так что лучше применять наследование.

По мере роста приложения, наши собственные ошибки образуют иерархию, например, HttpTimeoutError может наследовать от HttpError и так далее.

Практическое применение пользовательских исключений:
 - Прекращение выполнения операции при некорректных входных данных;
 - Бизнес-правила выявляют ошибки в ваших системах;
 - Интеграция с API сторонних сервисов требует обработки их специфических ошибок.

Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как err.cause

## 19. Promises, async/await и Event loop.

#### Promises

Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.

В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.

Что такое Promise?
Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

На promise можно навешивать колбэки двух типов:

 - onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
 - onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».

Способ использования, в общих чертах, такой:

 - Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
 - Внешний код, получив promise, навешивает на него обработчики.
 - По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания Promise:

```
var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически

  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})
```

Универсальный метод для навешивания обработчиков:

```
promise.then(onFulfilled, onRejected)
```

 - `onFulfilled` – функция, которая будет вызвана с результатом при resolve.
 - `onRejected` – функция, которая будет вызвана с ошибкой при reject.

С его помощью можно назначить как оба обработчика сразу, так и только один:

```
// onFulfilled сработает при успешном выполнении
promise.then(onFulfilled)
// onRejected сработает при ошибке
promise.then(null, onRejected)
```

`.catch` - Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.

Синхронный throw – то же самое, что reject.
Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:

```
'use strict';

let p = new Promise((resolve, reject) => {
  // то же что reject(new Error("o_O"))
  throw new Error("o_O");
})

p.catch(alert); // Error: o_O
```

#### Async/await

Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования.

Асинхронные функции
Начнём с ключевого слова async. Оно ставится перед функцией, вот так:

```
async function f() {
  return 1;
}
```

У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:

```
async function f() {
  return 1;
}

f().then(alert); // 1
```

Можно и явно вернуть промис, результат будет одинаковым:

```
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
```

Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – await, которое можно использовать только внутри async-функций.

**Await**

Синтаксис:

```
// работает только внутри async–функций
let value = await promise;
```

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:

```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
```

В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.

Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку.

#### Event loop

Алгоритм событийного цикла:

 1. Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
 2. Исполнить все микрозадачи:
  * Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
 3. Отрисовать изменения страницы, если они есть.
 4. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
 5. Перейти к шагу 1.

Чтобы добавить в очередь новую макрозадачу:

 - Используйте setTimeout(f) с нулевой задержкой.

Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).

Для добавления в очередь новой микрозадачи:

 - Используйте queueMicrotask(f).

Также обработчики промисов выполняются в рамках очереди микрозадач.

События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.

## 20. Основы сбора мусора.

Управление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции… Всё это занимает память.

#### Достижимость

Основной концепцией управления памятью в JavaScript является принцип достижимости.

Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

1. Существует базовое множество достижимых значений, которые не могут быть удалены.
  Например:
   - Выполняемая в данный момент функция, её локальные переменные и параметры.
   - Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
   - Глобальные переменные.
   - (некоторые другие внутренние значения)
  Эти значения мы будем называть корнями.
2. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
  Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.

В движке JavaScript есть фоновый процесс, который называется сборщиком мусора. Он отслеживает все объекты и удаляет те, которые стали недоступными.

#### Внутренние алгоритмы

Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

 - Сборщик мусора «помечает» (запоминает) все корневые объекты.
 - Затем он идёт по ним и «помечает» все ссылки из них.
 - Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
 - ...И так далее, пока не будут посещены все достижимые (из корней) ссылки.
 - Все непомеченные объекты удаляются.

Движки JavaScript применяют множество оптимизаций, чтобы она работала быстрее и не задерживала выполнение кода.

Вот некоторые из оптимизаций:

 - Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
 - Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
 - Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

Существуют и другие способы оптимизации и разновидности алгоритмов сборки мусора.

## 21. Понимание location браузера и history API.

## 22. Анализ user-agent и определение платформы/браузера (объект navigator).

## 23. Анализ, перекомпоновка, перерисовка и критический путь рендеринга.

## 24. Использование «Fetch» ​​и понимание «XMLHTTPRequest».

## 25. Различия между setTimeout и requestAnimationFrame.

## 26. Основные типы.

## 27. Перечисления.

## 28. Тип/интерфейс, различия между ними.

## 29. Использование интерфейсов с необязательными свойствами, свойствами только для чтения и т. д.

## 30. Типы функций.

## 31. Utility types `(необязательно)`.

## 32. Typeguards `(необязательно)`.

## 33. Создание пользовательских типов.

## 34. Дженерики (концепция).

## 35. Понимание системы модулей в ES6 и TypeScript.
